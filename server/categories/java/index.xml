<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on ARLOOR</title>
    <link>http://arloor.com/categories/java/</link>
    <description>Recent content in Java on ARLOOR</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 10 Jan 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://arloor.com/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于netty的http服务器实现</title>
      <link>http://arloor.com/posts/netty/httpserver-on-netty/</link>
      <pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/netty/httpserver-on-netty/</guid>
      <description>&lt;p&gt;现在发现自己代理的一个问题，准备将代理的http请求解析改用netty自带的一些组件，所以来研究一下netty源码中http服务器的实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java-AES加密后再Base64混淆</title>
      <link>http://arloor.com/posts/other/java-aes128-then-base64/</link>
      <pubDate>Fri, 04 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/other/java-aes128-then-base64/</guid>
      <description>&lt;p&gt;这是上一篇&lt;a href=&#34;http://arloor.com/posts/other/java-aes128/&#34;&gt;java-AES128加密-代码与一些约定&lt;/a&gt;的后续。这一篇将会记录自己看到的在AES128之后所做的混淆。混淆原来为c语言实现，自己转成了java实现。感觉这一套比较好用，所以记下来变成自己的😁咳咳，最终发现这个混淆就是对Base64的一个实现，只是将64个可打印字符的顺序弄乱了。所以我有了自定义Base64来实现混淆的代码？？？黑人问号&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java-AES128加密-代码与一些约定</title>
      <link>http://arloor.com/posts/other/java-aes128/</link>
      <pubDate>Thu, 03 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/other/java-aes128/</guid>
      <description>&lt;p&gt;在爬虫岗位实习，免不了接触加密解密，今天的工作中踩了一些java AES128加密的坑，也学习到了一些加密的常用做法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HttpProxy-基于netty的代理</title>
      <link>http://arloor.com/posts/netty/proxynew-break-the-wall-by-netty/</link>
      <pubDate>Mon, 31 Dec 2018 23:55:22 +0800</pubDate>
      
      <guid>http://arloor.com/posts/netty/proxynew-break-the-wall-by-netty/</guid>
      <description>&lt;p&gt;暑假使用java NIO实现了一个java http代理。那个http代理远远不算完善。之后学习了netty，并且使用netty实现了一个http代理，经过一个多月的使用，十分满意。今天来记录一下这里面值得写下来的东西。&lt;/p&gt;

&lt;p&gt;先放项目地址&lt;a href=&#34;https://github.com/arloor/HttpProxy&#34;&gt;HttpProxy&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Proxyme-基于javaNIO的http代理</title>
      <link>http://arloor.com/posts/netty/proxyme-based-on-javanio/</link>
      <pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/netty/proxyme-based-on-javanio/</guid>
      <description>proxyme 一个http代理 使用java NIO的http代理。支持https。建议不要再chrome上使用本代理，因为chrome本身会请求很多谷歌的api，结果被墙住了，又只有两个线程，导致其他都被阻塞，很尴尬。 之前也打算做过这个东西，结果做出来的有点缺陷（现在想可能是selector中锁的问题，忘记了）。这大概隔了半年，这个</description>
    </item>
    
    <item>
      <title>spring cloud学习（二）</title>
      <link>http://arloor.com/posts/microservice/spring_cloud-study-two/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/microservice/spring_cloud-study-two/</guid>
      <description>&lt;p&gt;spring cloud学习（一）中已经了有了注册与发现、服务消费、负载均衡、断路器。但是这不是完整的微服务架构。&lt;/p&gt;

&lt;p&gt;在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>spring cloud学习（一）</title>
      <link>http://arloor.com/posts/microservice/spring_cloud-study-one/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/microservice/spring_cloud-study-one/</guid>
      <description>作死了解一下spring cloud。当然，不知道能了解到什么程度。先作一死。 找到了一个博客，准备照着那个博客来搞搞博客地址。这个博客的好处是原理和介绍带一些，代码、pom、配置全都在博客中可以直接复制。第二点——可以直接复制黏贴实践，第一点——复制了能让你知道复制的是干了嘛。当然，原理和介绍稍微有点少，所以哈，最好还是</description>
    </item>
    
    <item>
      <title>redis与springboot整合学习</title>
      <link>http://arloor.com/posts/springboot/redis%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://arloor.com/posts/springboot/redis%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;p&gt;最近在做一个电商网站。今天想要实现一下购物车的功能。&lt;/p&gt;

&lt;p&gt;考虑问题如下：用户访问购物车会比较频繁，而且经常更改（比如修改数字）。对于后端的数据来说，也就是读写都很频繁。于是考虑通过redis，来减少对数据库的读写。&lt;/p&gt;

&lt;p&gt;就研究一下怎么使用redis以及整合到springboot中。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>