<!DOCTYPE html>
<html lang="zh-CN">

    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/rust-reqwest-hyper-http-client/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.157.0">

    
    
    

<title>Rust reqwest代码阅读 • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Rust reqwest代码阅读">
  <meta name="twitter:description" content="最近在自己的rust_http_proxy中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：
首先 TcpStream::connect 建立连接 通过 conn::http1::Builder 拿到 sender 发送请求 sender.send_request(new_req) 工作的很正常，但是没有连接池。想到 hyper 官方提供的 reqwest 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/rust-reqwest-hyper-http-client/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Rust reqwest代码阅读">
  <meta property="og:description" content="最近在自己的rust_http_proxy中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：
首先 TcpStream::connect 建立连接 通过 conn::http1::Builder 拿到 sender 发送请求 sender.send_request(new_req) 工作的很正常，但是没有连接池。想到 hyper 官方提供的 reqwest 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T11:26:42+08:00">
    <meta property="article:modified_time" content="2024-07-20T11:26:42+08:00">
    <meta property="article:tag" content="Rust">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.debf1b963c1830f6b9b96ee48c2b4a22c31c7c3885a87bed290c0e198fc6a08d.css" integrity="sha256-3r8bljwYMPa5uW7kjCtKIsMcfDiFqHvtKQwOGY/GoI0=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.6b7222b4ddd3cebd47d144a2e37ade6cbbb64f47e31d8feac655896156ade206.css" integrity="sha256-a3IitN3Tzr1H0USi43rebLu2T0fjHY/qxlWJYVat4gY=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>



<body class="  ">
  
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content menu-content--mobile">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana-iframe">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/net-iframe">
						<span>网速监控</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/nat">
						<span>NAT规则</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/stock">
						<span>股票监控</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me" target="_blank"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me" target="_blank"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me" target="_blank"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me" target="_blank"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    <div class="menu-content menu-content--desktop">
      <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana-iframe">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/net-iframe">
						<span>网速监控</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/nat">
						<span>NAT规则</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/stock">
						<span>股票监控</span>
					</a>
				</li>
			 
		
	</ul>
</div>

    </div>
    <div class="social-wrap social-wrap--desktop">
      <section class="social">
	
	<a href="https://x.com/njulgh" rel="me" target="_blank"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me" target="_blank"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me" target="_blank"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me" target="_blank"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
    </div>
    
<div class="copyright">
  &copy; 2026 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>

  <div class="content container">
    
    
<article>
  <header>
    <h1>Rust reqwest代码阅读</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jul 20, 2024
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/undefined">UNDEFINED</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/rust">rust</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 11 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#original无连接池的-reverse_proxy">Original：无连接池的 reverse_proxy</a></li>
    <li><a href="#源码阅读从-reqwest-到-hyper-util-再到-hyper">源码阅读：从 reqwest 到 hyper-util 再到 hyper</a>
      <ul>
        <li><a href="#reqwest-对-legacyclient-的使用">reqwest 对 legacy::client 的使用</a></li>
        <li><a href="#legacy-client-中池化的实现">legacy client 中池化的实现</a></li>
        <li><a href="#hyper-如何发送-http1-请求">hyper 如何发送 http1 请求</a></li>
      </ul>
    </li>
    <li><a href="#result1-使用-legacyclient-构建-reverse_proxy">Result1: 使用 legacy::client 构建 reverse_proxy</a></li>
    <li><a href="#result2-使用-lru-cache-实现自己的连接池">Result2: 使用 LRU cache 实现自己的连接池</a></li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>最近在自己的<a href="https://github.com/arloor/rust_http_proxy">rust_http_proxy</a>中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：</p>
<ol>
<li>首先 <code>TcpStream::connect</code> 建立连接</li>
<li>通过 <code>conn::http1::Builder</code> 拿到 <code>sender</code></li>
<li>发送请求 <code>sender.send_request(new_req)</code></li>
</ol>
<p>工作的很正常，但是没有连接池。想到 <code>hyper</code> 官方提供的 <code>reqwest</code> 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。</p>
<h2 id="original无连接池的-reverse_proxy">Original：无连接池的 reverse_proxy</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">reverse_proxy</span>(
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>Incoming<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// 原始请求
</span></span></span><span style="display:flex;"><span>        plain_host: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, <span style="color:#75715e">// 目标主机
</span></span></span><span style="display:flex;"><span>        plain_port: <span style="color:#66d9ef">u16</span>, <span style="color:#75715e">// 目标端口
</span></span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>BoxBody<span style="color:#f92672">&lt;</span>Bytes, io::Error<span style="color:#f92672">&gt;&gt;</span>, io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TcpStream::connect((plain_host, plain_port)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> io <span style="color:#f92672">=</span> TokioIo::new(stream);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> hyper::client::conn::http1::Builder::new()
</span></span><span style="display:flex;"><span>            .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .handshake(Box::pin(io))
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Ok((<span style="color:#66d9ef">mut</span> sender, conn)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokio::task::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { <span style="color:#75715e">// conn是一个future，tokio::spawn来poll它，驱动它完成
</span></span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(err) <span style="color:#f92672">=</span> conn.<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;reverse proxy connection failed: {:?}&#34;</span>, err);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> method <span style="color:#f92672">=</span> req.method().clone();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> req.uri().clone();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> url.path_and_query() {
</span></span><span style="display:flex;"><span>                    Some(path_and_query) <span style="color:#f92672">=&gt;</span> path_and_query.as_str(),
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;/&#34;</span>,
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> new_req_builder <span style="color:#f92672">=</span> Request::builder()
</span></span><span style="display:flex;"><span>                    .method(method.clone())
</span></span><span style="display:flex;"><span>                    .uri(url)
</span></span><span style="display:flex;"><span>                    .version(Version::<span style="color:#66d9ef">HTTP_11</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> ele <span style="color:#66d9ef">in</span> req.headers() {
</span></span><span style="display:flex;"><span>                    new_req_builder <span style="color:#f92672">=</span> new_req_builder.header(ele.<span style="color:#ae81ff">0</span>, ele.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;{}: {:?}&#34;</span>, ele.<span style="color:#ae81ff">0</span>, ele.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> new_req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>Incoming<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> new_req_builder
</span></span><span style="display:flex;"><span>                    .body(req.into_body())
</span></span><span style="display:flex;"><span>                    .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> io::Error::new(io::ErrorKind::InvalidData, e))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                new_req.headers_mut().remove(http::header::<span style="color:#66d9ef">HOST</span>.to_string());
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 这一版一定是HTTP/1.1，一定需要Host
</span></span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> target <span style="color:#f92672">=</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, plain_host, plain_port);
</span></span><span style="display:flex;"><span>                new_req.headers_mut().insert(
</span></span><span style="display:flex;"><span>                    http::header::<span style="color:#66d9ef">HOST</span>,
</span></span><span style="display:flex;"><span>                    HeaderValue::from_str(<span style="color:#f92672">&amp;</span>target).unwrap_or(HeaderValue::from_static(<span style="color:#e6db74">&#34;unknown&#34;</span>)),
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(resp) <span style="color:#f92672">=</span> sender.send_request(new_req).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                    Ok(resp.map(<span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                        b.map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> e <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>                            io::Error::new(ErrorKind::InvalidData, e)
</span></span><span style="display:flex;"><span>                        })
</span></span><span style="display:flex;"><span>                        .boxed()
</span></span><span style="display:flex;"><span>                    }))
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    Err(io::Error::new(ErrorKind::ConnectionAborted, <span style="color:#e6db74">&#34;连接失败&#34;</span>))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Err(e) <span style="color:#f92672">=&gt;</span> Err(io::Error::new(ErrorKind::ConnectionAborted, e)),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="源码阅读从-reqwest-到-hyper-util-再到-hyper">源码阅读：从 reqwest 到 hyper-util 再到 hyper</h2>
<h3 id="reqwest-对-legacyclient-的使用">reqwest 对 legacy::client 的使用</h3>
<p>具体 package 是:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper_util::client::legacy::client
</span></span></code></pre></div><p>下面是 <code>reqwest</code> 发起执行请求的代码，关注用 <code>!!!</code> 标注的注释</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#e6db74">/// Executes a `Request`.
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A `Request` can be built manually with `Request::new()` or obtained
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// from a RequestBuilder with `RequestBuilder::build()`.
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// You should prefer to use the `RequestBuilder` and
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// `RequestBuilder::send()`.
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// # Errors
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// This method fails if there was an error while sending request,
</span></span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// redirect loop was detected or redirect limit was exhausted.
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        request: <span style="color:#a6e22e">Request</span>, <span style="color:#75715e">// ！！！类型是 reqwest::async_impl::request，我们不能直接使用，看下面会转换成http::Reqwest
</span></span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>Response, <span style="color:#66d9ef">crate</span>::Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        self.execute_request(request)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">super</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute_request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span>) -&gt; <span style="color:#a6e22e">Pending</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (method, url, <span style="color:#66d9ef">mut</span> headers, body, timeout, version) <span style="color:#f92672">=</span> req.pieces();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;http&#34;</span> <span style="color:#f92672">&amp;&amp;</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;https&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Pending::new_err(error::url_bad_scheme(url));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// check if we&#39;re in https_only mode and check the scheme of the current URL
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.inner.https_only <span style="color:#f92672">&amp;&amp;</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;https&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Pending::new_err(error::url_bad_scheme(url));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// insert default headers in the request headers
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// without overwriting already appended headers.
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (key, value) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>self.inner.headers {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Entry::Vacant(entry) <span style="color:#f92672">=</span> headers.entry(key) {
</span></span><span style="display:flex;"><span>                entry.insert(value.clone());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add cookies from the cookie store.
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;cookies&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(cookie_store) <span style="color:#f92672">=</span> self.inner.cookie_store.as_ref() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> headers.get(<span style="color:#66d9ef">crate</span>::header::<span style="color:#66d9ef">COOKIE</span>).is_none() {
</span></span><span style="display:flex;"><span>                    add_cookie_header(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> headers, <span style="color:#f92672">&amp;**</span>cookie_store, <span style="color:#f92672">&amp;</span>url);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> accept_encoding <span style="color:#f92672">=</span> self.inner.accepts.as_str();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(accept_encoding) <span style="color:#f92672">=</span> accept_encoding {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>headers.contains_key(<span style="color:#66d9ef">ACCEPT_ENCODING</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>headers.contains_key(<span style="color:#66d9ef">RANGE</span>) {
</span></span><span style="display:flex;"><span>                headers.insert(<span style="color:#66d9ef">ACCEPT_ENCODING</span>, HeaderValue::from_static(accept_encoding));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> try_uri(<span style="color:#f92672">&amp;</span>url) {
</span></span><span style="display:flex;"><span>            Ok(uri) <span style="color:#f92672">=&gt;</span> uri,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Pending::new_err(error::url_invalid_uri(url)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (reusable, body) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> body {
</span></span><span style="display:flex;"><span>            Some(body) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> (reusable, body) <span style="color:#f92672">=</span> body.try_reuse();
</span></span><span style="display:flex;"><span>                (Some(reusable), body)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> (None, Body::empty()),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.proxy_auth(<span style="color:#f92672">&amp;</span>uri, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> headers);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> builder <span style="color:#f92672">=</span> hyper::Request::builder() <span style="color:#75715e">// ！！！转成我们可以直接使用的hyper::Request
</span></span></span><span style="display:flex;"><span>            .method(method.clone())
</span></span><span style="display:flex;"><span>            .uri(uri)
</span></span><span style="display:flex;"><span>            .version(version);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> in_flight <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> version {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http3&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            http::Version::<span style="color:#66d9ef">HTTP_3</span> <span style="color:#66d9ef">if</span> self.inner.h3_client.is_some() <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> req <span style="color:#f92672">=</span> builder.body(body).expect(<span style="color:#e6db74">&#34;valid request parts&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">*</span>req.headers_mut() <span style="color:#f92672">=</span> headers.clone();
</span></span><span style="display:flex;"><span>                ResponseFuture::H3(self.inner.h3_client.as_ref().unwrap().request(req))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> req <span style="color:#f92672">=</span> builder.body(body).expect(<span style="color:#e6db74">&#34;valid request parts&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">*</span>req.headers_mut() <span style="color:#f92672">=</span> headers.clone();
</span></span><span style="display:flex;"><span>                ResponseFuture::Default(self.inner.hyper.request(req)) <span style="color:#75715e">// ！！！调用hyper_util::client::legacy::client::Client
</span></span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> total_timeout <span style="color:#f92672">=</span> timeout
</span></span><span style="display:flex;"><span>            .or(self.inner.request_timeout)
</span></span><span style="display:flex;"><span>            .map(tokio::time::sleep)
</span></span><span style="display:flex;"><span>            .map(Box::pin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> read_timeout_fut <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>            .inner
</span></span><span style="display:flex;"><span>            .read_timeout
</span></span><span style="display:flex;"><span>            .map(tokio::time::sleep)
</span></span><span style="display:flex;"><span>            .map(Box::pin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Pending {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">PendingInner</span>::Request(PendingRequest {
</span></span><span style="display:flex;"><span>                method,
</span></span><span style="display:flex;"><span>                url,
</span></span><span style="display:flex;"><span>                headers,
</span></span><span style="display:flex;"><span>                body: <span style="color:#a6e22e">reusable</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                urls: Vec::new(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                retry_count: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                client: <span style="color:#a6e22e">self</span>.inner.clone(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                in_flight,
</span></span><span style="display:flex;"><span>                total_timeout,
</span></span><span style="display:flex;"><span>                read_timeout_fut,
</span></span><span style="display:flex;"><span>                read_timeout: <span style="color:#a6e22e">self</span>.inner.read_timeout,
</span></span><span style="display:flex;"><span>            }),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>看完这段代码之后，就知道核心是使用 <code>hyper-util</code> 的 <code>legacy client</code> 的 <code>request</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper_util::client::legacy::client::Client
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span> Client<span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">ResponseFuture</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Bounds from impl:
</span></span></span><span style="display:flex;"><span>    C: <span style="color:#a6e22e">Connect</span> <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> &#39;static <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>Send a constructed Request using this Client.
</span></span></code></pre></div><p>值得说明的是 <code>legacy client</code> 并不是“过时”的意思，而是 <code>hyper</code> 库从 <code>0.14</code> 升级到 <code>1.0</code> 时，将其从 <code>hyper</code> 移动到了 <code>hyper-util</code>。可以理解为从 hyper 体系的核心库移动到了外围实用组件。见下面引用自<a href="https://hyper.rs/guides/1/upgrading/">Upgrade from v0.14 to v1</a>的描述</p>
<blockquote>
<p>The higher-level pooling Client was removed from <code>hyper 1.0</code>. A similar type was added to <code>hyper-util</code>, called <code>client::legacy::Client</code>. It’s mostly a drop-in replacement.</p>
</blockquote>
<h3 id="legacy-client-中池化的实现">legacy client 中池化的实现</h3>
<p><code>legacy client</code> 的核心实现都在 <code>impl&lt;C, B&gt; Client&lt;C, B&gt;</code> 中，核心方法有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#75715e">// 发送请求
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">ResponseFuture</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从pool中找一条connection，发起请求
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_send_request</span>(<span style="color:#f92672">&amp;</span>self, <span style="color:#66d9ef">mut</span> req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>hyper::body::Incoming<span style="color:#f92672">&gt;</span>, TrySendError<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从pool中找一条connection
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connection_for</span>(<span style="color:#f92672">&amp;</span>self, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; Result<span style="color:#f92672">&lt;</span>pool::Pooled<span style="color:#f92672">&lt;</span>PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, PoolKey<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>大致流程时将 scheme、host、port 作为 pool_key 找到一个连接（PoolClient），然后使用 PoolClient 的 <code>try_send_request</code> 方法。 <code>try_send_request</code> 定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;</span> PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_send_request</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self,
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>hyper::body::Incoming<span style="color:#f92672">&gt;</span>, ConnTrySendError<span style="color:#f92672">&lt;</span>Request<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        B: Send,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(all(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">, feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http1(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> Either::Left(tx.try_send_request(req)),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http2(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> Either::Right(tx.try_send_request(req)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(not(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http1(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> tx.try_send_request(req),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(not(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http2(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> tx.try_send_request(req),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们走进 <code>http1</code> 的 <code>tx.try_send_request(req)</code>，发现这个 <code>PoolClient.tx</code> 就是之前无连接池版本中的 <code>sender</code>，就是下面这个 <code>handshake</code> 的返回的 tuple 的左值（右值是 Connection，会被 <code>tokio::spawn</code> 驱动执行）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper::client::conn::http1::Builder::new()
</span></span><span style="display:flex;"><span>    .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .handshake(Box::pin(io))
</span></span><span style="display:flex;"><span>    .<span style="color:#66d9ef">await</span>
</span></span></code></pre></div><p>至此，无连接池和有连接池的版本交会了，连接池中实际放的是就是之前的 <code>sender: http1::SendRequest</code>，见下面的定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#75715e">#[allow(missing_debug_implementations)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PoolClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    conn_info: <span style="color:#a6e22e">Connected</span>,
</span></span><span style="display:flex;"><span>    tx: <span style="color:#a6e22e">PoolTx</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PoolTx</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    Http1(hyper::client::conn::http1::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    Http2(hyper::client::conn::http2::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以额外关注下的 http1 部分，可以更清晰的看到和无连接连接池版本的相通之处</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper_util::client::legacy::client::Client
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span> Client<span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect_to</span>(<span style="color:#f92672">&amp;</span>self, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; <span style="color:#a6e22e">impl</span> Lazy<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>pool::Pooled<span style="color:#f92672">&lt;</span>PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, PoolKey<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">............</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> tx, conn) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    h1_builder.handshake(io).<span style="color:#66d9ef">await</span>.map_err(Error::tx)<span style="color:#f92672">?</span>; <span style="color:#75715e">// 1. 熟悉的hanshake
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http1 handshake complete, spawning background dispatcher task&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>executor.execute( <span style="color:#75715e">// 这里实际就是tokio::spawn，和无连接池版本一样
</span></span></span><span style="display:flex;"><span>    conn.with_upgrades()
</span></span><span style="display:flex;"><span>        .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;client connection error: {}&#34;</span>, e))
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> ()),
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Wait for &#39;conn&#39; to ready up before we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// declare this tx as usable
</span></span></span><span style="display:flex;"><span>tx.ready().<span style="color:#66d9ef">await</span>.map_err(Error::tx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> PoolTx::Http1(tx)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="hyper-如何发送-http1-请求">hyper 如何发送 http1 请求</h3>
<p>接下来从 hyper-util 走到 hyper，看看 hyper 这个底层库是如何发送 http 请求的。目标是确定我们将 http2 请求的 body 转换成 http1.1 的 body 是否有损，具体来说是，将 http2 分帧的 body 的转换成 http1.1 的<code>Transfer-Encoding: chunked</code>的 body 是否有损。答案是无损的。</p>
<p>我们先从上节的继续看起</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper::client::conn::http1::SendRequest
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>IncomingBody<span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Bounds from impl:
</span></span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> sent <span style="color:#f92672">=</span> self.dispatch.send(req); <span style="color:#75715e">// 返回的是respones的receiver
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> sent {
</span></span><span style="display:flex;"><span>        Ok(rx) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> rx.<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            Ok(Ok(resp)) <span style="color:#f92672">=&gt;</span> Ok(resp), <span style="color:#75715e">// 如果从receiver中拿到了response，返回
</span></span></span><span style="display:flex;"><span>            Ok(Err(err)) <span style="color:#f92672">=&gt;</span> Err(err),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// this is definite bug if it happens, but it shouldn&#39;t happen!
</span></span></span><span style="display:flex;"><span>            Err(_canceled) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">panic!</span>(<span style="color:#e6db74">&#34;dispatch dropped without returning error&#34;</span>),
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Err(_req) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;connection was not ready&#34;</span>);
</span></span><span style="display:flex;"><span>            Err(<span style="color:#66d9ef">crate</span>::Error::new_canceled().with(<span style="color:#e6db74">&#34;connection was not ready&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#f92672">........</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// self.dispatch.send(req);的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, val: <span style="color:#a6e22e">T</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Promise<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.can_send() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> oneshot::channel();
</span></span><span style="display:flex;"><span>    self.inner
</span></span><span style="display:flex;"><span>        .send(Envelope(Some((val, Callback::NoRetry(Some(tx))))))
</span></span><span style="display:flex;"><span>        .map(<span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> rx)
</span></span><span style="display:flex;"><span>        .map_err(<span style="color:#f92672">|</span><span style="color:#66d9ef">mut</span> e<span style="color:#f92672">|</span> (e.<span style="color:#ae81ff">0</span>).<span style="color:#ae81ff">0.</span>take().expect(<span style="color:#e6db74">&#34;envelope not dropped&#34;</span>).<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个 <code>inner.send</code> 是发送到了一个 channel 中，那这个 channel 的接收者在哪呢？答案是我们之前看到的被 <code>tokio::spawn</code> 的<code>Connection</code>中。这里有必要给出<code>Connection</code>的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#e6db74">/// A future that processes all HTTP state for the IO object.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// In most cases, this should just be spawned into an executor, so that it
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// can process incoming and outgoing messages, notice hangups, and the like.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#[must_use = </span><span style="color:#e6db74">&#34;futures do nothing unless polled&#34;</span><span style="color:#75715e">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">Dispatcher</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Connection 被 <code>tokio::spawn</code> 说明他是个 <code>Future</code>，他的逻辑就在 <code>poll</code> 方法中，我们看下这个 <code>poll</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> Connection<span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> <span style="color:#a6e22e">ready!</span>(Pin::new(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.inner).poll(cx))<span style="color:#f92672">?</span> { <span style="color:#75715e">// 调用 inner: Dispatcher&lt;T, B&gt; 的poll
</span></span></span><span style="display:flex;"><span>            proto::Dispatched::Shutdown <span style="color:#f92672">=&gt;</span> Poll::Ready(Ok(())),
</span></span><span style="display:flex;"><span>            proto::Dispatched::Upgrade(pending) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// With no `Send` bound on `I`, we can&#39;t try to do
</span></span></span><span style="display:flex;"><span>                <span style="color:#75715e">// upgrades here. In case a user was trying to use
</span></span></span><span style="display:flex;"><span>                <span style="color:#75715e">// `upgrade` with this API, send a special
</span></span></span><span style="display:flex;"><span>                <span style="color:#75715e">// error letting them know about that.
</span></span></span><span style="display:flex;"><span>                pending.manual();
</span></span><span style="display:flex;"><span>                Poll::Ready(Ok(()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里就是推动 <code>inner: Dispatcher</code>的执行，我们继续看 <code>Dispatcher</code> 的 poll（trait bounds 有点多，经典类型体操）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>D, Bs, I, T<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> Dispatcher<span style="color:#f92672">&lt;</span>D, Bs, I, T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    D: <span style="color:#a6e22e">Dispatch</span><span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>            PollItem <span style="color:#f92672">=</span> MessageHead<span style="color:#f92672">&lt;</span>T::Outgoing<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            PollBody <span style="color:#f92672">=</span> Bs,
</span></span><span style="display:flex;"><span>            RecvItem <span style="color:#f92672">=</span> MessageHead<span style="color:#f92672">&lt;</span>T::Incoming<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    D::PollError: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    I: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Http1Transaction</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    Bs: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    Bs::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>Dispatched<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.poll_catch(cx, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而后逐步走到 <code>poll_inner</code>、<code>poll_loop</code>，有经验而敏感的同学看到<code>poll_loop</code>就知道 Reacotr 模式的事件循环（eventloop）他来了。这个<code>poll_loop</code>值得贴一下源码，因为涉及到其他 future 的饥饿问题，可能自己在做设计的时候也要考虑</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_loop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Limit the looping on this connection, in case it is ready far too
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// often, so that other futures don&#39;t starve.
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 16 was chosen arbitrarily, as that is number of pipelined requests
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// benchmarks often use. Perhaps it should be a config option instead.
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">16</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_read(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_write(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_flush(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// This could happen if reading paused before blocking on IO,
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// such as getting to the end of a framed message, but then
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// writing/flushing set the state back to Init. In that case,
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if the read buffer still had bytes, we&#39;d want to try poll_read
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// again, or else we wouldn&#39;t ever be woken up again.
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Using this instead of task::current() and notify() inside
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// the Conn is noticeably faster in pipelined benchmarks.
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.conn.wants_read_again() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//break;
</span></span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Poll::Ready(Ok(()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;poll_loop yielding (self = {:p})&#34;</span>, self);
</span></span><span style="display:flex;"><span>    task::yield_now(cx).map(<span style="color:#f92672">|</span>never<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> never {}) <span style="color:#75715e">// 让出执行，避免其他饥饿
</span></span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着走进 <code>poll_write</code>的逻辑，就能看到具体的 http 请求的发送逻辑了。贴一小段代码，解密下消息从哪来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_write</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.is_closing {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Poll::Ready(Ok(()));
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> self.body_rx.is_none()
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> self.conn.can_write_head()
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> self.dispatch.should_poll()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(msg) <span style="color:#f92672">=</span> <span style="color:#a6e22e">ready!</span>(Pin::new(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.dispatch).poll_msg(cx)) { <span style="color:#75715e">// ！！！ 从channel中接收消息
</span></span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> (head, body) <span style="color:#f92672">=</span> msg.map_err(<span style="color:#66d9ef">crate</span>::Error::new_user_service)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> body_type <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> body.is_end_stream() {
</span></span><span style="display:flex;"><span>                    self.body_rx.set(None);
</span></span><span style="display:flex;"><span>                    None <span style="color:#75715e">// 长度为空
</span></span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> btype <span style="color:#f92672">=</span> body
</span></span><span style="display:flex;"><span>                        .size_hint()
</span></span><span style="display:flex;"><span>                        .exact()
</span></span><span style="display:flex;"><span>                        .map(BodyLength::Known)
</span></span><span style="display:flex;"><span>                        .or(Some(BodyLength::Unknown)); <span style="color:#75715e">// 从body中知道是固定长度的还是chunked的
</span></span></span><span style="display:flex;"><span>                    self.body_rx.set(Some(body));
</span></span><span style="display:flex;"><span>                    btype
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                self.conn.write_head(head, body_type); <span style="color:#75715e">// 写header部分，也是我们关注的chunked部分
</span></span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.conn.can_buffer_body() {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 接收body
</span></span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>核心在于 <code>self.dispatch</code> 的 <code>poll_msg</code> 方法，这个方法是 <code>Dispatcher</code> 的方法，我们看下这个方法的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> Dispatch <span style="color:#66d9ef">for</span> Client<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollItem</span> <span style="color:#f92672">=</span> RequestHead;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollBody</span> <span style="color:#f92672">=</span> B;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollError</span> <span style="color:#f92672">=</span> Infallible;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RecvItem</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::proto::ResponseHead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_msg</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>(Self::PollItem, Self::PollBody), Infallible<span style="color:#f92672">&gt;&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> this <span style="color:#f92672">=</span> self.as_mut();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">debug_assert!</span>(<span style="color:#f92672">!</span>this.rx_closed);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> this.rx.poll_recv(cx) {   <span style="color:#75715e">// ！！！ 从channel中接收消息，看下面的impl&lt;T, U&gt; Receiver&lt;T, U&gt;
</span></span></span><span style="display:flex;"><span>            Poll::Ready(Some((req, <span style="color:#66d9ef">mut</span> cb))) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Ready(None) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Pending <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Receiver</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">mpsc</span>::UnboundedReceiver<span style="color:#f92672">&lt;</span>Envelope<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    taker: <span style="color:#a6e22e">want</span>::Taker,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_recv</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>(T, Callback<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.inner.poll_recv(cx) {
</span></span><span style="display:flex;"><span>            Poll::Ready(item) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                Poll::Ready(item.map(<span style="color:#f92672">|</span><span style="color:#66d9ef">mut</span> env<span style="color:#f92672">|</span> env.<span style="color:#ae81ff">0.</span>take().expect(<span style="color:#e6db74">&#34;envelope not dropped&#34;</span>)))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.taker.want(); <span style="color:#75715e">// 如果没拿到，则通知生产者，详见下面的want crate解释
</span></span></span><span style="display:flex;"><span>                Poll::Pending
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">close</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        self.taker.cancel();
</span></span><span style="display:flex;"><span>        self.inner.close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_recv</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>(T, Callback<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">use</span> futures_util::FutureExt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.inner.recv().now_or_never() {
</span></span><span style="display:flex;"><span>            Some(Some(<span style="color:#66d9ef">mut</span> env)) <span style="color:#f92672">=&gt;</span> env.<span style="color:#ae81ff">0.</span>take(),
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在connection drop时，通知SendRequest is_closed
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Drop <span style="color:#66d9ef">for</span> Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Notify the giver about the closure first, before dropping
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// the mpsc::Receiver.
</span></span></span><span style="display:flex;"><span>        self.taker.cancel();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>核心是 <code>this.rx.poll_recv(cx)</code>，这个 rx 就是 <code>handshake</code> 过程中创建的 <code>dispatch::channel()</code> 的接受部分，底层是 <code>mpsc::UnboundedReceiver</code>。其实看到这里，应该就明白 hyper 怎么实现 client 的了：</p>
<ol>
<li>handshake 生成<code>sender: http1::SendRequest</code> 和 <code>Connection</code>。</li>
<li>他们是<strong>生产者消费者模型</strong>，sender 有 mpsc 的发送端，connection 有 mpsc 的接收端。<strong>我们自己实现 Rust 的生产者消费者模型时，可以重点参考<code>dispatch::channel()</code></strong></li>
<li>connection 被 tokio::spawn，poll 方法中不断从 mpsc 接收端接收消息，然后发送 http 请求。</li>
</ol>
<p>深究下 <code>dispatch::channel()</code> 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">channel</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>() -&gt; (Sender<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>, Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> mpsc::unbounded_channel();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (giver, taker) <span style="color:#f92672">=</span> want::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tx <span style="color:#f92672">=</span> Sender {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        buffered_once: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>        giver,
</span></span><span style="display:flex;"><span>        inner: <span style="color:#a6e22e">tx</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rx <span style="color:#f92672">=</span> Receiver { inner: <span style="color:#a6e22e">rx</span>, taker };
</span></span><span style="display:flex;"><span>    (tx, rx)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>用到了<a href="https://docs.rs/want/0.3.1/want/">hyper 作者的 want crate</a>。文档中写的很清楚，简单总结下，大致作用是给 channel 的生产者和消费者增加 http1 协议的 ping-pong 反馈机制，上一个 request 处理完毕，再允许发送者发送下一个 request（ping pong ping pong）(http2 的 stream 比这个复杂)。所以这个库的典型使用场景就是和 <code>unbounded_channel</code> 一起使用。</p>
<p>真正写 header 的部分，这里只截图我关注的 HTTP2 转 HTTP1.1 时是否能自动增加 <code>Transfer-Encoding: chunked</code>，简要总结下，如果没有设置 <code>Content-Length</code>，则会自动增加 <code>Transfer-Encoding: chunked</code>。截图左侧的调用栈也可以关注下。</p>
<p><img src="/img/hyper_http1_poll_write_debug.png" alt="alt text"></p>
<h2 id="result1-使用-legacyclient-构建-reverse_proxy">Result1: 使用 legacy::client 构建 reverse_proxy</h2>
<p>增加的依赖：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hyper-rustls</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0&#34;</span>, <span style="color:#a6e22e">default-features</span> = <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">features</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;rustls-platform-verifier&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http2&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;native-tokio&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http1&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;logging&#34;</span>,
</span></span><span style="display:flex;"><span>] }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hyper-util</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;tokio&#34;</span>, <span style="color:#e6db74">&#34;server-auto&#34;</span>] }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustls</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustls-native-certs</span> = <span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">webpki-roots</span> = <span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">http</span> = <span style="color:#e6db74">&#34;1&#34;</span>
</span></span></code></pre></div><p>hyper-rustls 中的 ring 或者 aws-lc-rs 是受自己 crate 的可选 feature 控制的，这里没有展示出来。下面是构建<code>legacy client</code>的代码，支持 HTTPS：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build_http_client</span>() -&gt; <span style="color:#a6e22e">Client</span><span style="color:#f92672">&lt;</span>hyper_rustls::HttpsConnector<span style="color:#f92672">&lt;</span>HttpConnector<span style="color:#f92672">&gt;</span>, Incoming<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个 HttpConnector
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> http_connector <span style="color:#f92672">=</span> HttpConnector::new();
</span></span><span style="display:flex;"><span>    http_connector.enforce_http(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    http_connector.set_keepalive(Some(Duration::from_secs(<span style="color:#ae81ff">90</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> root_cert_store <span style="color:#f92672">=</span> rustls::RootCertStore::empty();
</span></span><span style="display:flex;"><span>    root_cert_store.extend(webpki_roots::<span style="color:#66d9ef">TLS_SERVER_ROOTS</span>.iter().cloned());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> valid_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> invalid_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(a) <span style="color:#f92672">=</span> rustls_native_certs::load_native_certs() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> cert <span style="color:#66d9ef">in</span> a {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Continue on parsing errors, as native stores often include ancient or syntactically
</span></span></span><span style="display:flex;"><span>            <span style="color:#75715e">// invalid certificates, like root certificates without any X509 extensions.
</span></span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Inspiration: https://github.com/rustls/rustls/blob/633bf4ba9d9521a95f68766d04c22e2b01e68318/rustls/src/anchors.rs#L105-L112
</span></span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> root_cert_store.add(cert) {
</span></span><span style="display:flex;"><span>                Ok(_) <span style="color:#f92672">=&gt;</span> valid_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    invalid_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    log::<span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;rustls failed to parse DER certificate: {err:?}&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    log::<span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;rustls_native_certs found {valid_count} valid and {invalid_count} invalid certificates for reverse proxy&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> client_tls_config <span style="color:#f92672">=</span> rustls::ClientConfig::builder()
</span></span><span style="display:flex;"><span>        .with_root_certificates(root_cert_store)
</span></span><span style="display:flex;"><span>        .with_no_client_auth();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> https_connector <span style="color:#f92672">=</span> HttpsConnectorBuilder::new()
</span></span><span style="display:flex;"><span>        .with_tls_config(client_tls_config)
</span></span><span style="display:flex;"><span>        .https_or_http()
</span></span><span style="display:flex;"><span>        .enable_all_versions()
</span></span><span style="display:flex;"><span>        .wrap_connector(http_connector);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个 HttpsConnector，使用 rustls 作为后端
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> client: <span style="color:#a6e22e">Client</span><span style="color:#f92672">&lt;</span>hyper_rustls::HttpsConnector<span style="color:#f92672">&lt;</span>HttpConnector<span style="color:#f92672">&gt;</span>, Incoming<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        Client::builder(TokioExecutor::new())
</span></span><span style="display:flex;"><span>            .pool_idle_timeout(Duration::from_secs(<span style="color:#ae81ff">90</span>))
</span></span><span style="display:flex;"><span>            .pool_max_idle_per_host(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>            .pool_timer(hyper_util::rt::TokioTimer::new())
</span></span><span style="display:flex;"><span>            .build(https_connector);
</span></span><span style="display:flex;"><span>    client
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="result2-使用-lru-cache-实现自己的连接池">Result2: 使用 LRU cache 实现自己的连接池</h2>
<p>最后，我又借鉴了 <code>shadowsocks-rust</code> 的 <a href="https://github.com/shadowsocks/shadowsocks-rust/blob/dc5ea4b39de4e5223c48877d18d85b931c799302/crates/shadowsocks-service/src/local/http/http_client.rs#L112">http_client.rs</a>，使用 <code>lru_time_cache</code> 实现了自己的连接池。在过程中还修复了它的一个bug：<a href="https://github.com/shadowsocks/shadowsocks-rust/pull/2062">fix(http): add is_ready method and enhance connection checks</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#e6db74">//! HTTP Client
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>    collections::VecDeque,
</span></span><span style="display:flex;"><span>    error::Error,
</span></span><span style="display:flex;"><span>    fmt::Debug,
</span></span><span style="display:flex;"><span>    io::{self, ErrorKind},
</span></span><span style="display:flex;"><span>    sync::Arc,
</span></span><span style="display:flex;"><span>    time::Instant,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> http::{HeaderMap, HeaderValue, Version, header};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper::{
</span></span><span style="display:flex;"><span>    Request, Response,
</span></span><span style="display:flex;"><span>    body::{self, Body},
</span></span><span style="display:flex;"><span>    client::conn::http1::{self},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper_util::rt::TokioIo;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> io_x::{CounterIO, TimeoutIO};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> log::{debug, error, info, trace, warn};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> lru_time_cache::LruCache;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> prom_label::LabelImpl;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio::sync::Mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio_rustls::rustls::pki_types;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::proxy::{AccessLabel, EitherTlsStream, build_tls_connector};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// ForwardProxyClient, supporting HTTP/1.1 and H2, HTTPS.
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ForwardProxyClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[allow(clippy::type_complexity)]</span>
</span></span><span style="display:flex;"><span>    cache_conn: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>LruCache<span style="color:#f92672">&lt;</span>AccessLabel, VecDeque<span style="color:#f92672">&lt;</span>(HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, Instant)<span style="color:#f92672">&gt;&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> ForwardProxyClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin <span style="color:#f92672">+</span> Debug <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ::std::error::Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Create a new HttpClient
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">ForwardProxyClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        ForwardProxyClient {
</span></span><span style="display:flex;"><span>            cache_conn: <span style="color:#a6e22e">Arc</span>::new(Mutex::new(LruCache::with_expiry_duration_and_capacity(<span style="color:#66d9ef">crate</span>::<span style="color:#66d9ef">IDLE_TIMEOUT</span>, <span style="color:#ae81ff">100</span>))),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[allow(unused)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request_no_cache</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>, ipv6_first: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        stream_map_func: <span style="color:#a6e22e">impl</span> FnOnce(EitherTlsStream, AccessLabel) -&gt; <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>EitherTlsStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;</span>, std::io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Make a new connection
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> c <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> HttpConnection::connect(access_label, ipv6_first, stream_map_func).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            Ok(c) <span style="color:#f92672">=&gt;</span> c,
</span></span><span style="display:flex;"><span>            Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">error!</span>(<span style="color:#e6db74">&#34;failed to connect to host: {}, error: {}&#34;</span>, <span style="color:#f92672">&amp;</span>access_label.target, err);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Err(io::Error::new(io::ErrorKind::InvalidData, err));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;HTTP making request to host: {access_label}, request: {req:?}&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> c.send_request(req).<span style="color:#66d9ef">await</span>.map_err(io::Error::other)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;HTTP received response from host: {access_label}, response: {response:?}&#34;</span>);
</span></span><span style="display:flex;"><span>        Ok(response)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Make HTTP requests
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>, ipv6_first: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        stream_map_func: <span style="color:#a6e22e">impl</span> FnOnce(EitherTlsStream, AccessLabel) -&gt; <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>EitherTlsStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;</span>, std::io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. Check if there is an available client
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(c) <span style="color:#f92672">=</span> self.get_cached_connection(access_label).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP client for host: {} taken from cache&#34;</span>, <span style="color:#f92672">&amp;</span>access_label);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> self.send_request_conn(access_label, c, req).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                Ok(o) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Ok(o),
</span></span><span style="display:flex;"><span>                Err(err) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(io::Error::new(io::ErrorKind::InvalidData, err)),
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. If no. Make a new connection
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> HttpConnection::connect(access_label, ipv6_first, stream_map_func).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            Ok(c) <span style="color:#f92672">=&gt;</span> c,
</span></span><span style="display:flex;"><span>            Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">error!</span>(<span style="color:#e6db74">&#34;failed to connect to host: {}, error: {}&#34;</span>, <span style="color:#f92672">&amp;</span>access_label.target, err);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Err(io::Error::new(io::ErrorKind::InvalidData, err));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.send_request_conn(access_label, c, req)
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>            .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> io::Error::new(io::ErrorKind::InvalidData, e))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_cached_connection</span>(<span style="color:#f92672">&amp;</span>self, access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>) -&gt; Option<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(q) <span style="color:#f92672">=</span> self.cache_conn.lock().<span style="color:#66d9ef">await</span>.get_mut(access_label) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP client for host: {} found in cache, len: {}&#34;</span>, access_label, q.len());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some((c, inst)) <span style="color:#f92672">=</span> q.pop_front() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> now <span style="color:#f92672">=</span> Instant::now();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> now <span style="color:#f92672">-</span> inst <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">crate</span>::<span style="color:#66d9ef">IDLE_TIMEOUT</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {access_label} expired&#34;</span>,);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> c.is_closed() {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// true at once after connection.await return
</span></span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {access_label} is closed&#34;</span>,);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>c.is_ready() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {access_label} is not ready&#34;</span>,);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Some(c);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP client for host: {access_label} not found in cache&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request_conn</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self, access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>, <span style="color:#66d9ef">mut</span> c: <span style="color:#a6e22e">HttpConnection</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">hyper</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;HTTP making request to host: {access_label}, request: {req:?}&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> req.uri().clone();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> c.send_request(req).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;HTTP received response from host: {access_label}, response: {response:?}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check keep-alive
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> check_keep_alive(response.version(), response.headers(), <span style="color:#66d9ef">false</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;HTTP connection keep-alive for host: {access_label}, response: {response:?}&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> cache_conn <span style="color:#f92672">=</span> self.cache_conn.clone();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> access_label <span style="color:#f92672">=</span> access_label.clone();
</span></span><span style="display:flex;"><span>            tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> c.ready().<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                    Ok(_) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">info!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {access_label} {url} is ready and will be cached&#34;</span>);
</span></span><span style="display:flex;"><span>                        cache_conn
</span></span><span style="display:flex;"><span>                            .lock()
</span></span><span style="display:flex;"><span>                            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>                            .entry(access_label)
</span></span><span style="display:flex;"><span>                            .or_insert_with(VecDeque::new)
</span></span><span style="display:flex;"><span>                            .push_back((c, Instant::now()));
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {access_label} {url} failed to become ready: {}&#34;</span>, e);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(response)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_keep_alive</span>(version: <span style="color:#a6e22e">Version</span>, headers: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HeaderMap</span><span style="color:#f92672">&lt;</span>HeaderValue<span style="color:#f92672">&gt;</span>, check_proxy: <span style="color:#66d9ef">bool</span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// HTTP/1.1, HTTP/2, HTTP/3 keeps alive by default
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> conn_keep_alive <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">matches!</span>(version, Version::<span style="color:#66d9ef">HTTP_09</span> <span style="color:#f92672">|</span> Version::<span style="color:#66d9ef">HTTP_10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> check_proxy {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Modern browsers will send Proxy-Connection instead of Connection
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// for HTTP/1.0 proxies which blindly forward Connection to remote
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span>        <span style="color:#75715e">// https://tools.ietf.org/html/rfc7230#appendix-A.1.2
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(b) <span style="color:#f92672">=</span> get_keep_alive_val(headers.get_all(<span style="color:#e6db74">&#34;Proxy-Connection&#34;</span>)) {
</span></span><span style="display:flex;"><span>            conn_keep_alive <span style="color:#f92672">=</span> b
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Connection will replace Proxy-Connection
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// But why client sent both Connection and Proxy-Connection? That&#39;s not standard!
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(b) <span style="color:#f92672">=</span> get_keep_alive_val(headers.get_all(<span style="color:#e6db74">&#34;Connection&#34;</span>)) {
</span></span><span style="display:flex;"><span>        conn_keep_alive <span style="color:#f92672">=</span> b
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    conn_keep_alive
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_keep_alive_val</span>(values: <span style="color:#a6e22e">header</span>::GetAll<span style="color:#f92672">&lt;</span>HeaderValue<span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> conn_keep_alive <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> value <span style="color:#66d9ef">in</span> values {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(value) <span style="color:#f92672">=</span> value.to_str() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> value.eq_ignore_ascii_case(<span style="color:#e6db74">&#34;close&#34;</span>) {
</span></span><span style="display:flex;"><span>                conn_keep_alive <span style="color:#f92672">=</span> Some(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> part <span style="color:#66d9ef">in</span> value.split(<span style="color:#e6db74">&#39;,&#39;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> part <span style="color:#f92672">=</span> part.trim();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> part.eq_ignore_ascii_case(<span style="color:#e6db74">&#34;keep-alive&#34;</span>) {
</span></span><span style="display:flex;"><span>                        conn_keep_alive <span style="color:#f92672">=</span> Some(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    conn_keep_alive
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(dead_code)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">HttpConnection</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Http1(http1::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ::std::error::Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect</span>(
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>, ipv6_first: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        stream_map_func: <span style="color:#a6e22e">impl</span> FnOnce(EitherTlsStream, AccessLabel) -&gt; <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>EitherTlsStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::proxy::connect_with_preference(<span style="color:#f92672">&amp;</span>access_label.target, ipv6_first).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(<span style="color:#66d9ef">true</span>) <span style="color:#f92672">=</span> access_label.relay_over_tls {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 建立 TLS 连接
</span></span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> connector <span style="color:#f92672">=</span> build_tls_connector();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> host <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>access_label
</span></span><span style="display:flex;"><span>                .target
</span></span><span style="display:flex;"><span>                .split(<span style="color:#e6db74">&#39;:&#39;</span>)
</span></span><span style="display:flex;"><span>                .next()
</span></span><span style="display:flex;"><span>                .ok_or(io::Error::other(<span style="color:#e6db74">&#34;invalid host&#34;</span>))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> server_name <span style="color:#f92672">=</span> pki_types::ServerName::try_from(<span style="color:#f92672">*</span>host)
</span></span><span style="display:flex;"><span>                .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> io::Error::new(ErrorKind::InvalidInput, <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;Invalid DNS name: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, e)))<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>                .to_owned();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> connector.connect(server_name, stream).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                Ok(tls_stream) <span style="color:#f92672">=&gt;</span> EitherTlsStream::Tls { stream: <span style="color:#a6e22e">tls_stream</span> },
</span></span><span style="display:flex;"><span>                Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[forward_bypass TLS handshake error] [{}]: {}&#34;</span>, access_label, e);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> Err(e);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 使用普通 TCP 连接
</span></span></span><span style="display:flex;"><span>            EitherTlsStream::Tcp { stream }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream: <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>EitherTlsStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> stream_map_func(stream, access_label.clone());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        HttpConnection::connect_http_http1(access_label, stream).<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect_http_http1</span>(
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>, stream: <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>EitherTlsStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TimeoutIO::new(stream, <span style="color:#66d9ef">crate</span>::<span style="color:#66d9ef">IDLE_TIMEOUT</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// HTTP/1.x
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (send_request, connection) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> http1::Builder::new()
</span></span><span style="display:flex;"><span>            .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .handshake(Box::pin(TokioIo::new(stream)))
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Ok(s) <span style="color:#f92672">=&gt;</span> s,
</span></span><span style="display:flex;"><span>            Err(err) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(io::Error::other(err)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> access_label <span style="color:#f92672">=</span> access_label.clone();
</span></span><span style="display:flex;"><span>        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(err) <span style="color:#f92672">=</span> connection.with_upgrades().<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                handle_http1_connection_error(err, access_label);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        Ok(HttpConnection::Http1(send_request))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">hyper</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.send_request(req).<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_closed</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.is_closed(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_ready</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.is_ready(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ready</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Result<span style="color:#f92672">&lt;</span>(), hyper::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.ready().<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handle_http1_connection_error</span>(err: <span style="color:#a6e22e">hyper</span>::Error, access_label: <span style="color:#a6e22e">AccessLabel</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(source) <span style="color:#f92672">=</span> err.source() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(io_err) <span style="color:#f92672">=</span> source.downcast_ref::<span style="color:#f92672">&lt;</span>io::Error<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> io_err.kind() <span style="color:#f92672">==</span> ErrorKind::TimedOut {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 由于超时导致的连接关闭（TimeoutIO）
</span></span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">info!</span>(<span style="color:#e6db74">&#34;[legacy proxy connection io closed]: [{}] {} to {}&#34;</span>, io_err.kind(), io_err, access_label);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[legacy proxy io error]: [{}] {} to {}&#34;</span>, io_err.kind(), io_err, access_label);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[legacy proxy io error]: [{source}] to {access_label}&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[legacy proxy io error] [{err}] to {access_label}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/afterburner-profile/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Afterburner配置文件备份</span>
    </a>
    
    
    <a href="/posts/homebrew-versioned/" class="navigation-next">
      <span class="navigation-tittle">Homebrew安装指定版本的软件</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


  </div>
<style>
  .content.container {
        width: 100%;
        max-width: none;
        height: calc(100vh - var(--sidebar-height, 49px));
        border: none;
        display: block;
        overflow-y: auto;
        box-sizing: border-box;
        margin-left: 0;
        margin-right: 0;
  }

  body:not(.type-iframe) .content.container {
        padding-left: max(1.5rem, calc((100% - var(--content-max-width, 38rem)) / 2));
        padding-right: max(1.5rem, calc((100% - var(--content-max-width, 38rem)) / 2));
  }
</style>
<script>
    (function () {
        var contentSelector = '.content.container';
        var rafId = 0;
        var resizeDebounceTimer = 0;
        var pendingHashScroll = false;

        function getHashTarget() {
            var hash = window.location.hash;
            var targetId = '';

            if (!hash || hash === '#') {
                return null;
            }

            targetId = hash.slice(1);
            try {
                targetId = decodeURIComponent(targetId);
            } catch (e) {
                
            }

            return document.getElementById(targetId);
        }

        function scrollToHashTarget() {
            var target = getHashTarget();
            if (!target) {
                return;
            }
            try {
                target.scrollIntoView({ block: 'start', inline: 'nearest' });
            } catch (e) {
                target.scrollIntoView(true);
            }
        }

        function applyPendingHashScroll() {
            if (!pendingHashScroll) {
                return;
            }
            pendingHashScroll = false;
            scrollToHashTarget();
        }

        function resizeContentHeight() {
            var content = document.querySelector(contentSelector);
            if (!content) {
                return;
            }
            var rect = content.getBoundingClientRect();
            var available = window.innerHeight - rect.top;
            if (available < 0) {
                available = 0;
            }
            content.style.height = available + 'px';
            applyPendingHashScroll();
        }

        function scheduleResize() {
            if (rafId) {
                return;
            }
            rafId = window.requestAnimationFrame(function () {
                rafId = 0;
                resizeContentHeight();
            });
        }

        function scheduleResizeDebounced(delay) {
            window.clearTimeout(resizeDebounceTimer);
            resizeDebounceTimer = window.setTimeout(scheduleResize, delay || 120);
        }

        function requestHashScroll() {
            if (!window.location.hash || window.location.hash === '#') {
                return;
            }
            pendingHashScroll = true;
            scheduleResize();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                scheduleResize();
                requestHashScroll();
            }, { once: true });
        } else {
            scheduleResize();
            requestHashScroll();
        }

        window.addEventListener('load', function () {
            scheduleResize();
            requestHashScroll();
        });
        window.addEventListener('pageshow', function () {
            scheduleResize();
            requestHashScroll();
        });
        window.addEventListener('hashchange', requestHashScroll);
        window.addEventListener('resize', function () {
            scheduleResizeDebounced(120);
        });

        var menuToggle = document.getElementById('menuToggle');
        if (menuToggle) {
            menuToggle.addEventListener('change', function () {
                scheduleResize();
                window.setTimeout(scheduleResize, 250);
            });
        }
    })();
</script>
  
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    

<style>
    .code-block-wrapper {
        position: relative;
    }
    .copy-code-button {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 6px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s, background 0.3s;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .copy-code-button svg {
        width: 16px;
        height: 16px;
        fill: #fff;
        transition: fill 0.3s;
    }
    .code-block-wrapper:hover .copy-code-button {
        opacity: 1;
    }
    .copy-code-button:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    .copy-code-button.copied {
        background: rgba(46, 160, 67, 0.8);
        border-color: rgba(46, 160, 67, 1);
    }
    .copy-code-button.copied svg {
        fill: #fff;
    }
</style>
<script type="text/javascript">
    document.addEventListener('DOMContentLoaded', function() {
        
        document.querySelectorAll('pre code').forEach(function(codeBlock) {
            var pre = codeBlock.parentNode;
            
            
            if (pre.parentNode.classList.contains('code-block-wrapper')) {
                return;
            }
            
            
            var wrapper = document.createElement('div');
            wrapper.className = 'code-block-wrapper';
            pre.parentNode.insertBefore(wrapper, pre);
            wrapper.appendChild(pre);
            
            
            var button = document.createElement('button');
            button.className = 'copy-code-button';
            button.innerHTML = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
            button.setAttribute('aria-label', '复制代码');
            button.setAttribute('title', '复制代码');
            
            var copyIcon = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
            var checkIcon = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path></svg>';
            
            
            button.addEventListener('click', function() {
                var code = codeBlock.textContent;
                navigator.clipboard.writeText(code).then(function() {
                    button.innerHTML = checkIcon;
                    button.classList.add('copied');
                    button.setAttribute('aria-label', '已复制');
                    button.setAttribute('title', '已复制');
                    setTimeout(function() {
                        button.innerHTML = copyIcon;
                        button.classList.remove('copied');
                        button.setAttribute('aria-label', '复制代码');
                        button.setAttribute('title', '复制代码');
                    }, 2000);
                }).catch(function(err) {
                    console.error('复制失败:', err);
                });
            });
            
            wrapper.appendChild(button);
        });
    });
</script>




    



</body>

</html>
