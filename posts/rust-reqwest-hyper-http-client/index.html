<!DOCTYPE html>
<html lang="zh-CN">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/rust-reqwest-hyper-http-client/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.148.0">

    
    
    

<title>Rust reqwest代码阅读 • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Rust reqwest代码阅读">
  <meta name="twitter:description" content="最近在自己的rust_http_proxy中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：
首先 TcpStream::connect 建立连接 通过 conn::http1::Builder 拿到 sender 发送请求 sender.send_request(new_req) 工作的很正常，但是没有连接池。想到 hyper 官方提供的 reqwest 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/rust-reqwest-hyper-http-client/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Rust reqwest代码阅读">
  <meta property="og:description" content="最近在自己的rust_http_proxy中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：
首先 TcpStream::connect 建立连接 通过 conn::http1::Builder 拿到 sender 发送请求 sender.send_request(new_req) 工作的很正常，但是没有连接池。想到 hyper 官方提供的 reqwest 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T11:26:42+08:00">
    <meta property="article:modified_time" content="2024-07-20T11:26:42+08:00">
    <meta property="article:tag" content="Rust">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.484b96856b25751067d56c8c0af9dc1fd6372707029b6d56ee178da6bead45b5.css" integrity="sha256-SEuWhWsldRBn1WyMCvncH9Y3JwcCm21W7heNpr6tRbU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.0873834b0f2e9fdc9e1d0301e8ebce21fc10383882a41e9373f29b90e85a9987.css" integrity="sha256-CHODSw8un9yeHQMB6OvOIfwQODiCpB6Tc/KbkOhamYc=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="http://beian.miit.gov.cn/">
						<span>沪ICP备2025110448号</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    
<div class="copyright">
  &copy; 2025 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>
        <div class="content container">
            
    
<article>
  <header>
    <h1>Rust reqwest代码阅读</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jul 20, 2024
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/undefined">UNDEFINED</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/rust">rust</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 11 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#original无连接池的reverse_proxy">Original：无连接池的reverse_proxy</a></li>
    <li><a href="#源码阅读从reqwest到hyper-util再到hyper">源码阅读：从reqwest到hyper-util再到hyper</a>
      <ul>
        <li><a href="#reqwest对-legacyclient-的使用">reqwest对 legacy::client 的使用</a></li>
        <li><a href="#legacy-client中池化的实现">legacy client中池化的实现</a></li>
        <li><a href="#hyper如何发送http1请求">hyper如何发送http1请求</a></li>
      </ul>
    </li>
    <li><a href="#result1-使用legacyclient构建reverse_proxy">Result1: 使用legacy::client构建reverse_proxy</a></li>
    <li><a href="#result2-使用lru-cache实现自己的连接池">Result2: 使用LRU cache实现自己的连接池</a></li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>最近在自己的<a href="https://github.com/arloor/rust_http_proxy">rust_http_proxy</a>中实现了简单的反向代理，第一版用的是手搓的无连接池版本，大致流程如下：</p>
<ol>
<li>首先 <code>TcpStream::connect</code> 建立连接</li>
<li>通过 <code>conn::http1::Builder</code> 拿到 <code>sender</code></li>
<li>发送请求 <code>sender.send_request(new_req)</code></li>
</ol>
<p>工作的很正常，但是没有连接池。想到 <code>hyper</code> 官方提供的 <code>reqwest</code> 是有内置连接池的，于是研究了下做了改造，记录下过程中读到的代码。</p>
<h2 id="original无连接池的reverse_proxy">Original：无连接池的reverse_proxy</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">reverse_proxy</span>(
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>Incoming<span style="color:#f92672">&gt;</span>, <span style="color:#75715e">// 原始请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        plain_host: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, <span style="color:#75715e">// 目标主机
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        plain_port: <span style="color:#66d9ef">u16</span>, <span style="color:#75715e">// 目标端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>BoxBody<span style="color:#f92672">&lt;</span>Bytes, io::Error<span style="color:#f92672">&gt;&gt;</span>, io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TcpStream::connect((plain_host, plain_port)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> io <span style="color:#f92672">=</span> TokioIo::new(stream);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> hyper::client::conn::http1::Builder::new()
</span></span><span style="display:flex;"><span>            .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .handshake(Box::pin(io))
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Ok((<span style="color:#66d9ef">mut</span> sender, conn)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                tokio::task::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> { <span style="color:#75715e">// conn是一个future，tokio::spawn来poll它，驱动它完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(err) <span style="color:#f92672">=</span> conn.<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;reverse proxy connection failed: {:?}&#34;</span>, err);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> method <span style="color:#f92672">=</span> req.method().clone();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> req.uri().clone();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> url <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> url.path_and_query() {
</span></span><span style="display:flex;"><span>                    Some(path_and_query) <span style="color:#f92672">=&gt;</span> path_and_query.as_str(),
</span></span><span style="display:flex;"><span>                    None <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;/&#34;</span>,
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> new_req_builder <span style="color:#f92672">=</span> Request::builder()
</span></span><span style="display:flex;"><span>                    .method(method.clone())
</span></span><span style="display:flex;"><span>                    .uri(url)
</span></span><span style="display:flex;"><span>                    .version(Version::<span style="color:#66d9ef">HTTP_11</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> ele <span style="color:#66d9ef">in</span> req.headers() {
</span></span><span style="display:flex;"><span>                    new_req_builder <span style="color:#f92672">=</span> new_req_builder.header(ele.<span style="color:#ae81ff">0</span>, ele.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;{}: {:?}&#34;</span>, ele.<span style="color:#ae81ff">0</span>, ele.<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> new_req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>Incoming<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> new_req_builder
</span></span><span style="display:flex;"><span>                    .body(req.into_body())
</span></span><span style="display:flex;"><span>                    .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> io::Error::new(io::ErrorKind::InvalidData, e))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                new_req.headers_mut().remove(http::header::<span style="color:#66d9ef">HOST</span>.to_string());
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 这一版一定是HTTP/1.1，一定需要Host
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> target <span style="color:#f92672">=</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, plain_host, plain_port);
</span></span><span style="display:flex;"><span>                new_req.headers_mut().insert(
</span></span><span style="display:flex;"><span>                    http::header::<span style="color:#66d9ef">HOST</span>,
</span></span><span style="display:flex;"><span>                    HeaderValue::from_str(<span style="color:#f92672">&amp;</span>target).unwrap_or(HeaderValue::from_static(<span style="color:#e6db74">&#34;unknown&#34;</span>)),
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(resp) <span style="color:#f92672">=</span> sender.send_request(new_req).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                    Ok(resp.map(<span style="color:#f92672">|</span>b<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                        b.map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">let</span> e <span style="color:#f92672">=</span> e;
</span></span><span style="display:flex;"><span>                            io::Error::new(ErrorKind::InvalidData, e)
</span></span><span style="display:flex;"><span>                        })
</span></span><span style="display:flex;"><span>                        .boxed()
</span></span><span style="display:flex;"><span>                    }))
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    Err(io::Error::new(ErrorKind::ConnectionAborted, <span style="color:#e6db74">&#34;连接失败&#34;</span>))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Err(e) <span style="color:#f92672">=&gt;</span> Err(io::Error::new(ErrorKind::ConnectionAborted, e)),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="源码阅读从reqwest到hyper-util再到hyper">源码阅读：从reqwest到hyper-util再到hyper</h2>
<h3 id="reqwest对-legacyclient-的使用">reqwest对 legacy::client 的使用</h3>
<p>具体package是:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper_util::client::legacy::client
</span></span></code></pre></div><p>下面是 <code>reqwest</code> 发起执行请求的代码，关注用 <code>!!!</code> 标注的注释</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#e6db74">/// Executes a `Request`.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// A `Request` can be built manually with `Request::new()` or obtained
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// from a RequestBuilder with `RequestBuilder::build()`.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// You should prefer to use the `RequestBuilder` and
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// `RequestBuilder::send()`.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// # Errors
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// This method fails if there was an error while sending request,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// redirect loop was detected or redirect limit was exhausted.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        request: <span style="color:#a6e22e">Request</span>, <span style="color:#75715e">// ！！！类型是 reqwest::async_impl::request，我们不能直接使用，看下面会转换成http::Reqwest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>Response, <span style="color:#66d9ef">crate</span>::Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        self.execute_request(request)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">super</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute_request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span>) -&gt; <span style="color:#a6e22e">Pending</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (method, url, <span style="color:#66d9ef">mut</span> headers, body, timeout, version) <span style="color:#f92672">=</span> req.pieces();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;http&#34;</span> <span style="color:#f92672">&amp;&amp;</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;https&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Pending::new_err(error::url_bad_scheme(url));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// check if we&#39;re in https_only mode and check the scheme of the current URL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> self.inner.https_only <span style="color:#f92672">&amp;&amp;</span> url.scheme() <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;https&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Pending::new_err(error::url_bad_scheme(url));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// insert default headers in the request headers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// without overwriting already appended headers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (key, value) <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>self.inner.headers {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Entry::Vacant(entry) <span style="color:#f92672">=</span> headers.entry(key) {
</span></span><span style="display:flex;"><span>                entry.insert(value.clone());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Add cookies from the cookie store.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;cookies&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(cookie_store) <span style="color:#f92672">=</span> self.inner.cookie_store.as_ref() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> headers.get(<span style="color:#66d9ef">crate</span>::header::<span style="color:#66d9ef">COOKIE</span>).is_none() {
</span></span><span style="display:flex;"><span>                    add_cookie_header(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> headers, <span style="color:#f92672">&amp;**</span>cookie_store, <span style="color:#f92672">&amp;</span>url);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> accept_encoding <span style="color:#f92672">=</span> self.inner.accepts.as_str();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(accept_encoding) <span style="color:#f92672">=</span> accept_encoding {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>headers.contains_key(<span style="color:#66d9ef">ACCEPT_ENCODING</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>headers.contains_key(<span style="color:#66d9ef">RANGE</span>) {
</span></span><span style="display:flex;"><span>                headers.insert(<span style="color:#66d9ef">ACCEPT_ENCODING</span>, HeaderValue::from_static(accept_encoding));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> uri <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> try_uri(<span style="color:#f92672">&amp;</span>url) {
</span></span><span style="display:flex;"><span>            Ok(uri) <span style="color:#f92672">=&gt;</span> uri,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Pending::new_err(error::url_invalid_uri(url)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (reusable, body) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> body {
</span></span><span style="display:flex;"><span>            Some(body) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> (reusable, body) <span style="color:#f92672">=</span> body.try_reuse();
</span></span><span style="display:flex;"><span>                (Some(reusable), body)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> (None, Body::empty()),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.proxy_auth(<span style="color:#f92672">&amp;</span>uri, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> headers);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> builder <span style="color:#f92672">=</span> hyper::Request::builder() <span style="color:#75715e">// ！！！转成我们可以直接使用的hyper::Request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            .method(method.clone())
</span></span><span style="display:flex;"><span>            .uri(uri)
</span></span><span style="display:flex;"><span>            .version(version);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> in_flight <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> version {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http3&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            http::Version::<span style="color:#66d9ef">HTTP_3</span> <span style="color:#66d9ef">if</span> self.inner.h3_client.is_some() <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> req <span style="color:#f92672">=</span> builder.body(body).expect(<span style="color:#e6db74">&#34;valid request parts&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">*</span>req.headers_mut() <span style="color:#f92672">=</span> headers.clone();
</span></span><span style="display:flex;"><span>                ResponseFuture::H3(self.inner.h3_client.as_ref().unwrap().request(req))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> req <span style="color:#f92672">=</span> builder.body(body).expect(<span style="color:#e6db74">&#34;valid request parts&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">*</span>req.headers_mut() <span style="color:#f92672">=</span> headers.clone();
</span></span><span style="display:flex;"><span>                ResponseFuture::Default(self.inner.hyper.request(req)) <span style="color:#75715e">// ！！！调用hyper_util::client::legacy::client::Client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> total_timeout <span style="color:#f92672">=</span> timeout
</span></span><span style="display:flex;"><span>            .or(self.inner.request_timeout)
</span></span><span style="display:flex;"><span>            .map(tokio::time::sleep)
</span></span><span style="display:flex;"><span>            .map(Box::pin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> read_timeout_fut <span style="color:#f92672">=</span> self
</span></span><span style="display:flex;"><span>            .inner
</span></span><span style="display:flex;"><span>            .read_timeout
</span></span><span style="display:flex;"><span>            .map(tokio::time::sleep)
</span></span><span style="display:flex;"><span>            .map(Box::pin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Pending {
</span></span><span style="display:flex;"><span>            inner: <span style="color:#a6e22e">PendingInner</span>::Request(PendingRequest {
</span></span><span style="display:flex;"><span>                method,
</span></span><span style="display:flex;"><span>                url,
</span></span><span style="display:flex;"><span>                headers,
</span></span><span style="display:flex;"><span>                body: <span style="color:#a6e22e">reusable</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                urls: Vec::new(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                retry_count: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                client: <span style="color:#a6e22e">self</span>.inner.clone(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                in_flight,
</span></span><span style="display:flex;"><span>                total_timeout,
</span></span><span style="display:flex;"><span>                read_timeout_fut,
</span></span><span style="display:flex;"><span>                read_timeout: <span style="color:#a6e22e">self</span>.inner.read_timeout,
</span></span><span style="display:flex;"><span>            }),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>看完这段代码之后，就知道核心是使用 <code>hyper-util</code> 的 <code>legacy client</code> 的 <code>request</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper_util::client::legacy::client::Client
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span> Client<span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">ResponseFuture</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Bounds from impl:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C: <span style="color:#a6e22e">Connect</span> <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> &#39;static <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>Send a constructed Request using this Client.
</span></span></code></pre></div><p>值得说明的是 <code>legacy client</code> 并不是“过时”的意思，而是 <code>hyper</code> 库从 <code>0.14</code> 升级到 <code>1.0</code> 时，将其从 <code>hyper</code> 移动到了 <code>hyper-util</code>。可以理解为从hyper体系的核心库移动到了外围实用组件。见下面引用自<a href="https://hyper.rs/guides/1/upgrading/">Upgrade from v0.14 to v1</a>的描述</p>
<blockquote>
<p>The higher-level pooling Client was removed from <code>hyper 1.0</code>. A similar type was added to <code>hyper-util</code>, called <code>client::legacy::Client</code>. It’s mostly a drop-in replacement.</p></blockquote>
<h3 id="legacy-client中池化的实现">legacy client中池化的实现</h3>
<p><code>legacy client</code> 的核心实现都在 <code>impl&lt;C, B&gt; Client&lt;C, B&gt;</code> 中，核心方法有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#75715e">// 发送请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">request</span>(<span style="color:#f92672">&amp;</span>self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">ResponseFuture</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从pool中找一条connection，发起请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_send_request</span>(<span style="color:#f92672">&amp;</span>self, <span style="color:#66d9ef">mut</span> req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>hyper::body::Incoming<span style="color:#f92672">&gt;</span>, TrySendError<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从pool中找一条connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connection_for</span>(<span style="color:#f92672">&amp;</span>self, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; Result<span style="color:#f92672">&lt;</span>pool::Pooled<span style="color:#f92672">&lt;</span>PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, PoolKey<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>大致流程时将scheme、host、port作为pool_key找到一个连接（PoolClient），然后使用PoolClient的 <code>try_send_request</code> 方法。 <code>try_send_request</code> 定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;</span> PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_send_request</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self,
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>hyper::body::Incoming<span style="color:#f92672">&gt;</span>, ConnTrySendError<span style="color:#f92672">&lt;</span>Request<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        B: Send,
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(all(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">, feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http1(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> Either::Left(tx.try_send_request(req)),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http2(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> Either::Right(tx.try_send_request(req)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(not(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http1(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> tx.try_send_request(req),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(not(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">match</span> self.tx {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>            PoolTx::Http2(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> tx) <span style="color:#f92672">=&gt;</span> tx.try_send_request(req),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们走进 <code>http1</code> 的 <code>tx.try_send_request(req)</code>，发现这个 <code>PoolClient.tx</code> 就是之前无连接池版本中的 <code>sender</code>，就是下面这个 <code>handshake</code> 的返回的tuple的左值（右值是Connection，会被 <code>tokio::spawn</code> 驱动执行）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper::client::conn::http1::Builder::new()
</span></span><span style="display:flex;"><span>    .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    .handshake(Box::pin(io))
</span></span><span style="display:flex;"><span>    .<span style="color:#66d9ef">await</span>
</span></span></code></pre></div><p>至此，无连接池和有连接池的版本交会了，连接池中实际放的是就是之前的 <code>sender: http1::SendRequest</code>，见下面的定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#75715e">#[allow(missing_debug_implementations)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PoolClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    conn_info: <span style="color:#a6e22e">Connected</span>,
</span></span><span style="display:flex;"><span>    tx: <span style="color:#a6e22e">PoolTx</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">PoolTx</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    Http1(hyper::client::conn::http1::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http2&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    Http2(hyper::client::conn::http2::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以额外关注下的http1部分，可以更清晰的看到和无连接连接池版本的相通之处</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper_util::client::legacy::client::Client
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span> Client<span style="color:#f92672">&lt;</span>C, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect_to</span>(<span style="color:#f92672">&amp;</span>self, pool_key: <span style="color:#a6e22e">PoolKey</span>) -&gt; <span style="color:#a6e22e">impl</span> Lazy<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>pool::Pooled<span style="color:#f92672">&lt;</span>PoolClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, PoolKey<span style="color:#f92672">&gt;</span>, Error<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">............</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> tx, conn) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    h1_builder.handshake(io).<span style="color:#66d9ef">await</span>.map_err(Error::tx)<span style="color:#f92672">?</span>; <span style="color:#75715e">// 1. 熟悉的hanshake
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http1 handshake complete, spawning background dispatcher task&#34;</span>
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>executor.execute( <span style="color:#75715e">// 这里实际就是tokio::spawn，和无连接池版本一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    conn.with_upgrades()
</span></span><span style="display:flex;"><span>        .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;client connection error: {}&#34;</span>, e))
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> ()),
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Wait for &#39;conn&#39; to ready up before we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// declare this tx as usable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tx.ready().<span style="color:#66d9ef">await</span>.map_err(Error::tx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> PoolTx::Http1(tx)
</span></span><span style="display:flex;"><span>}                            
</span></span></code></pre></div><h3 id="hyper如何发送http1请求">hyper如何发送http1请求</h3>
<p>接下来从hyper-util走到hyper，看看hyper这个底层库是如何发送http请求的。目标是确定我们将http2请求的body转换成http1.1的body是否有损，具体来说是，将http2分帧的body的转换成http1.1的<code>Transfer-Encoding: chunked</code>的body是否有损。答案是无损的。</p>
<p>我们先从上节的继续看起</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>hyper::client::conn::http1::SendRequest
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>IncomingBody<span style="color:#f92672">&gt;&gt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Bounds from impl:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> sent <span style="color:#f92672">=</span> self.dispatch.send(req); <span style="color:#75715e">// 返回的是respones的receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> sent {
</span></span><span style="display:flex;"><span>        Ok(rx) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> rx.<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            Ok(Ok(resp)) <span style="color:#f92672">=&gt;</span> Ok(resp), <span style="color:#75715e">// 如果从receiver中拿到了response，返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Ok(Err(err)) <span style="color:#f92672">=&gt;</span> Err(err),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// this is definite bug if it happens, but it shouldn&#39;t happen!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Err(_canceled) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">panic!</span>(<span style="color:#e6db74">&#34;dispatch dropped without returning error&#34;</span>),
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        Err(_req) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;connection was not ready&#34;</span>);
</span></span><span style="display:flex;"><span>            Err(<span style="color:#66d9ef">crate</span>::Error::new_canceled().with(<span style="color:#e6db74">&#34;connection was not ready&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#f92672">........</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// self.dispatch.send(req);的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, val: <span style="color:#a6e22e">T</span>) -&gt; Result<span style="color:#f92672">&lt;</span>Promise<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span>, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.can_send() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Err(val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> oneshot::channel();
</span></span><span style="display:flex;"><span>    self.inner
</span></span><span style="display:flex;"><span>        .send(Envelope(Some((val, Callback::NoRetry(Some(tx))))))
</span></span><span style="display:flex;"><span>        .map(<span style="color:#66d9ef">move</span> <span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> rx)
</span></span><span style="display:flex;"><span>        .map_err(<span style="color:#f92672">|</span><span style="color:#66d9ef">mut</span> e<span style="color:#f92672">|</span> (e.<span style="color:#ae81ff">0</span>).<span style="color:#ae81ff">0.</span>take().expect(<span style="color:#e6db74">&#34;envelope not dropped&#34;</span>).<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个 <code>inner.send</code> 是发送到了一个channel中，那这个channel的接收者在哪呢？答案是我们之前看到的被 <code>tokio::spawn</code> 的<code>Connection</code>中。这里有必要给出<code>Connection</code>的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#e6db74">/// A future that processes all HTTP state for the IO object.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">///
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// In most cases, this should just be spawned into an executor, so that it
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// can process incoming and outgoing messages, notice hangups, and the like.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[must_use = </span><span style="color:#e6db74">&#34;futures do nothing unless polled&#34;</span><span style="color:#75715e">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Connection</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">Dispatcher</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Connection被 <code>tokio::spawn</code> 说明他是个 <code>Future</code>，他的逻辑就在 <code>poll</code> 方法中，我们看下这个 <code>poll</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> Connection<span style="color:#f92672">&lt;</span>T, B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> <span style="color:#a6e22e">ready!</span>(Pin::new(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.inner).poll(cx))<span style="color:#f92672">?</span> { <span style="color:#75715e">// 调用 inner: Dispatcher&lt;T, B&gt; 的poll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            proto::Dispatched::Shutdown <span style="color:#f92672">=&gt;</span> Poll::Ready(Ok(())),
</span></span><span style="display:flex;"><span>            proto::Dispatched::Upgrade(pending) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// With no `Send` bound on `I`, we can&#39;t try to do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// upgrades here. In case a user was trying to use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// `upgrade` with this API, send a special
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// error letting them know about that.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                pending.manual();
</span></span><span style="display:flex;"><span>                Poll::Ready(Ok(()))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里就是推动 <code>inner: Dispatcher</code>的执行，我们继续看 <code>Dispatcher</code> 的poll（trait bounds有点多，经典类型体操）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>D, Bs, I, T<span style="color:#f92672">&gt;</span> Future <span style="color:#66d9ef">for</span> Dispatcher<span style="color:#f92672">&lt;</span>D, Bs, I, T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    D: <span style="color:#a6e22e">Dispatch</span><span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>            PollItem <span style="color:#f92672">=</span> MessageHead<span style="color:#f92672">&lt;</span>T::Outgoing<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>            PollBody <span style="color:#f92672">=</span> Bs,
</span></span><span style="display:flex;"><span>            RecvItem <span style="color:#f92672">=</span> MessageHead<span style="color:#f92672">&lt;</span>T::Incoming<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    D::PollError: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    I: <span style="color:#a6e22e">Read</span> <span style="color:#f92672">+</span> Write <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    T: <span style="color:#a6e22e">Http1Transaction</span> <span style="color:#f92672">+</span> Unpin,
</span></span><span style="display:flex;"><span>    Bs: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    Bs::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> StdError <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>Dispatched<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        self.poll_catch(cx, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而后逐步走到 <code>poll_inner</code>、<code>poll_loop</code>，有经验而敏感的同学看到<code>poll_loop</code>就知道 Reacotr模式的事件循环（eventloop）他来了。这个<code>poll_loop</code>值得贴一下源码，因为涉及到其他future的饥饿问题，可能自己在做设计的时候也要考虑</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_loop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Limit the looping on this connection, in case it is ready far too
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// often, so that other futures don&#39;t starve.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 16 was chosen arbitrarily, as that is number of pipelined requests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// benchmarks often use. Perhaps it should be a config option instead.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">16</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_read(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_write(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> self.poll_flush(cx)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// This could happen if reading paused before blocking on IO,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// such as getting to the end of a framed message, but then
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// writing/flushing set the state back to Init. In that case,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// if the read buffer still had bytes, we&#39;d want to try poll_read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// again, or else we wouldn&#39;t ever be woken up again.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Using this instead of task::current() and notify() inside
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// the Conn is noticeably faster in pipelined benchmarks.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.conn.wants_read_again() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//break;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> Poll::Ready(Ok(()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">trace!</span>(<span style="color:#e6db74">&#34;poll_loop yielding (self = {:p})&#34;</span>, self);
</span></span><span style="display:flex;"><span>    task::yield_now(cx).map(<span style="color:#f92672">|</span>never<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> never {}) <span style="color:#75715e">// 让出执行，避免其他饥饿
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>接着走进 <code>poll_write</code>的逻辑，就能看到具体的http请求的发送逻辑了。贴一小段代码，解密下消息从哪来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_write</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">crate</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.is_closing {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Poll::Ready(Ok(()));
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> self.body_rx.is_none()
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> self.conn.can_write_head()
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;&amp;</span> self.dispatch.should_poll()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(msg) <span style="color:#f92672">=</span> <span style="color:#a6e22e">ready!</span>(Pin::new(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.dispatch).poll_msg(cx)) { <span style="color:#75715e">// ！！！ 从channel中接收消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> (head, body) <span style="color:#f92672">=</span> msg.map_err(<span style="color:#66d9ef">crate</span>::Error::new_user_service)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> body_type <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> body.is_end_stream() {
</span></span><span style="display:flex;"><span>                    self.body_rx.set(None);
</span></span><span style="display:flex;"><span>                    None <span style="color:#75715e">// 长度为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> btype <span style="color:#f92672">=</span> body
</span></span><span style="display:flex;"><span>                        .size_hint()
</span></span><span style="display:flex;"><span>                        .exact()
</span></span><span style="display:flex;"><span>                        .map(BodyLength::Known)
</span></span><span style="display:flex;"><span>                        .or(Some(BodyLength::Unknown)); <span style="color:#75715e">// 从body中知道是固定长度的还是chunked的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    self.body_rx.set(Some(body));
</span></span><span style="display:flex;"><span>                    btype
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>                self.conn.write_head(head, body_type); <span style="color:#75715e">// 写header部分，也是我们关注的chunked部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.conn.can_buffer_body() {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 接收body
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>核心在于 <code>self.dispatch</code> 的 <code>poll_msg</code> 方法，这个方法是 <code>Dispatcher</code> 的方法，我们看下这个方法的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> Dispatch <span style="color:#66d9ef">for</span> Client<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollItem</span> <span style="color:#f92672">=</span> RequestHead;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollBody</span> <span style="color:#f92672">=</span> B;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">PollError</span> <span style="color:#f92672">=</span> Infallible;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RecvItem</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::proto::ResponseHead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_msg</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Result<span style="color:#f92672">&lt;</span>(Self::PollItem, Self::PollBody), Infallible<span style="color:#f92672">&gt;&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> this <span style="color:#f92672">=</span> self.as_mut();
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">debug_assert!</span>(<span style="color:#f92672">!</span>this.rx_closed);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> this.rx.poll_recv(cx) {   <span style="color:#75715e">// ！！！ 从channel中接收消息，看下面的impl&lt;T, U&gt; Receiver&lt;T, U&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Poll::Ready(Some((req, <span style="color:#66d9ef">mut</span> cb))) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Ready(None) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Pending <span style="color:#f92672">=&gt;</span> Poll::Pending,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">..</span>.
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Receiver</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    inner: <span style="color:#a6e22e">mpsc</span>::UnboundedReceiver<span style="color:#f92672">&lt;</span>Envelope<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    taker: <span style="color:#a6e22e">want</span>::Taker,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_recv</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>(T, Callback<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.inner.poll_recv(cx) {
</span></span><span style="display:flex;"><span>            Poll::Ready(item) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                Poll::Ready(item.map(<span style="color:#f92672">|</span><span style="color:#66d9ef">mut</span> env<span style="color:#f92672">|</span> env.<span style="color:#ae81ff">0.</span>take().expect(<span style="color:#e6db74">&#34;envelope not dropped&#34;</span>)))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.taker.want(); <span style="color:#75715e">// 如果没拿到，则通知生产者，详见下面的want crate解释
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                Poll::Pending
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">close</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        self.taker.cancel();
</span></span><span style="display:flex;"><span>        self.inner.close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">try_recv</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>(T, Callback<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">use</span> futures_util::FutureExt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self.inner.recv().now_or_never() {
</span></span><span style="display:flex;"><span>            Some(Some(<span style="color:#66d9ef">mut</span> env)) <span style="color:#f92672">=&gt;</span> env.<span style="color:#ae81ff">0.</span>take(),
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在connection drop时，通知SendRequest is_closed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> Drop <span style="color:#66d9ef">for</span> Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Notify the giver about the closure first, before dropping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// the mpsc::Receiver.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        self.taker.cancel();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>核心是 <code>this.rx.poll_recv(cx)</code>，这个rx就是 <code>handshake</code> 过程中创建的 <code>dispatch::channel()</code> 的接受部分，底层是 <code>mpsc::UnboundedReceiver</code>。其实看到这里，应该就明白hyper怎么实现client的了：</p>
<ol>
<li>handshake生成<code>sender: http1::SendRequest</code> 和 <code>Connection</code>。</li>
<li>他们是<strong>生产者消费者模型</strong>，sender有mpsc的发送端，connection有mpsc的接收端。<strong>我们自己实现Rust的生产者消费者模型时，可以重点参考<code>dispatch::channel()</code></strong></li>
<li>connection被tokio::spawn，poll方法中不断从mpsc接收端接收消息，然后发送http请求。</li>
</ol>
<p>深究下 <code>dispatch::channel()</code> 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">channel</span><span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>() -&gt; (Sender<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>, Receiver<span style="color:#f92672">&lt;</span>T, U<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> mpsc::unbounded_channel();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (giver, taker) <span style="color:#f92672">=</span> want::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tx <span style="color:#f92672">=</span> Sender {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;http1&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span>        buffered_once: <span style="color:#a6e22e">false</span>,
</span></span><span style="display:flex;"><span>        giver,
</span></span><span style="display:flex;"><span>        inner: <span style="color:#a6e22e">tx</span>,
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rx <span style="color:#f92672">=</span> Receiver { inner: <span style="color:#a6e22e">rx</span>, taker };
</span></span><span style="display:flex;"><span>    (tx, rx)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>用到了<a href="https://docs.rs/want/0.3.1/want/">hyper作者的want crate</a>。文档中写的很清楚，简单总结下，大致作用是给channel的生产者和消费者增加http1协议的ping-pong反馈机制，上一个request处理完毕，再允许发送者发送下一个request（ping pong ping pong）(http2的stream比这个复杂)。所以这个库的典型使用场景就是和 <code>unbounded_channel</code> 一起使用。</p>
<p>真正写header的部分，这里只截图我关注的HTTP2转HTTP1.1时是否能自动增加 <code>Transfer-Encoding: chunked</code>，简要总结下，如果没有设置 <code>Content-Length</code>，则会自动增加 <code>Transfer-Encoding: chunked</code>。截图左侧的调用栈也可以关注下。</p>
<p><img src="/img/hyper_http1_poll_write_debug.png" alt="alt text"></p>
<h2 id="result1-使用legacyclient构建reverse_proxy">Result1: 使用legacy::client构建reverse_proxy</h2>
<p>增加的依赖：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hyper-rustls</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0&#34;</span>, <span style="color:#a6e22e">default-features</span> = <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">features</span> = [
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;rustls-platform-verifier&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http2&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;native-tokio&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;http1&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;logging&#34;</span>,
</span></span><span style="display:flex;"><span>] } 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hyper-util</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1&#34;</span>, <span style="color:#a6e22e">features</span> = [<span style="color:#e6db74">&#34;tokio&#34;</span>, <span style="color:#e6db74">&#34;server-auto&#34;</span>] }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustls</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rustls-native-certs</span> = <span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">webpki-roots</span> = <span style="color:#e6db74">&#34;0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">http</span> = <span style="color:#e6db74">&#34;1&#34;</span>
</span></span></code></pre></div><p>hyper-rustls中的ring或者aws-lc-rs是受自己crate的可选feature控制的，这里没有展示出来。下面是构建<code>legacy client</code>的代码，支持HTTPS：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build_http_client</span>() -&gt; <span style="color:#a6e22e">Client</span><span style="color:#f92672">&lt;</span>hyper_rustls::HttpsConnector<span style="color:#f92672">&lt;</span>HttpConnector<span style="color:#f92672">&gt;</span>, Incoming<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个 HttpConnector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> http_connector <span style="color:#f92672">=</span> HttpConnector::new();
</span></span><span style="display:flex;"><span>    http_connector.enforce_http(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>    http_connector.set_keepalive(Some(Duration::from_secs(<span style="color:#ae81ff">90</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> root_cert_store <span style="color:#f92672">=</span> rustls::RootCertStore::empty();
</span></span><span style="display:flex;"><span>    root_cert_store.extend(webpki_roots::<span style="color:#66d9ef">TLS_SERVER_ROOTS</span>.iter().cloned());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> valid_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> invalid_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(a) <span style="color:#f92672">=</span> rustls_native_certs::load_native_certs() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> cert <span style="color:#66d9ef">in</span> a {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Continue on parsing errors, as native stores often include ancient or syntactically
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// invalid certificates, like root certificates without any X509 extensions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// Inspiration: https://github.com/rustls/rustls/blob/633bf4ba9d9521a95f68766d04c22e2b01e68318/rustls/src/anchors.rs#L105-L112
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">match</span> root_cert_store.add(cert) {
</span></span><span style="display:flex;"><span>                Ok(_) <span style="color:#f92672">=&gt;</span> valid_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    invalid_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                    log::<span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;rustls failed to parse DER certificate: {err:?}&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    log::<span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;rustls_native_certs found {valid_count} valid and {invalid_count} invalid certificates for reverse proxy&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> client_tls_config <span style="color:#f92672">=</span> rustls::ClientConfig::builder()
</span></span><span style="display:flex;"><span>        .with_root_certificates(root_cert_store)
</span></span><span style="display:flex;"><span>        .with_no_client_auth();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> https_connector <span style="color:#f92672">=</span> HttpsConnectorBuilder::new()
</span></span><span style="display:flex;"><span>        .with_tls_config(client_tls_config)
</span></span><span style="display:flex;"><span>        .https_or_http()
</span></span><span style="display:flex;"><span>        .enable_all_versions()
</span></span><span style="display:flex;"><span>        .wrap_connector(http_connector);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个 HttpsConnector，使用 rustls 作为后端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> client: <span style="color:#a6e22e">Client</span><span style="color:#f92672">&lt;</span>hyper_rustls::HttpsConnector<span style="color:#f92672">&lt;</span>HttpConnector<span style="color:#f92672">&gt;</span>, Incoming<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        Client::builder(TokioExecutor::new())
</span></span><span style="display:flex;"><span>            .pool_idle_timeout(Duration::from_secs(<span style="color:#ae81ff">90</span>))
</span></span><span style="display:flex;"><span>            .pool_max_idle_per_host(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>            .pool_timer(hyper_util::rt::TokioTimer::new())
</span></span><span style="display:flex;"><span>            .build(https_connector);
</span></span><span style="display:flex;"><span>    client
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="result2-使用lru-cache实现自己的连接池">Result2: 使用LRU cache实现自己的连接池</h2>
<p>最后，我又借鉴了 <code>shadowsocks-rust</code> 的 <code>http_client.rs</code>，使用 <code>lru_time_cache</code> 实现了自己的连接池。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#e6db74">//! HTTP Client
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>    collections::VecDeque,
</span></span><span style="display:flex;"><span>    error::Error,
</span></span><span style="display:flex;"><span>    fmt::Debug,
</span></span><span style="display:flex;"><span>    io::{self, ErrorKind},
</span></span><span style="display:flex;"><span>    sync::Arc,
</span></span><span style="display:flex;"><span>    time::{Duration, Instant},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> http::{header, HeaderMap, HeaderValue, Version};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper::{
</span></span><span style="display:flex;"><span>    body::{self, Body},
</span></span><span style="display:flex;"><span>    client::conn::http1,
</span></span><span style="display:flex;"><span>    http::uri::Scheme,
</span></span><span style="display:flex;"><span>    Request, Response,
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper_util::rt::TokioIo;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> io_x::{CounterIO, TimeoutIO};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> log::{debug, error, info, trace, warn};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> lru_time_cache::LruCache;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> prom_label::LabelImpl;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> tokio::{net::TcpStream, sync::Mutex};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::proxy::AccessLabel;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">CONNECTION_EXPIRE_DURATION</span>: <span style="color:#a6e22e">Duration</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    Duration::from_secs(<span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">cfg!</span>(debug_assertions) { <span style="color:#ae81ff">30</span> } <span style="color:#66d9ef">else</span> { <span style="color:#ae81ff">10</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// HTTPClient, supporting HTTP/1.1 and H2, HTTPS.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">HttpClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[allow(clippy::type_complexity)]</span>
</span></span><span style="display:flex;"><span>    cache_conn: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>Mutex<span style="color:#f92672">&lt;</span>LruCache<span style="color:#f92672">&lt;</span>AccessLabel, VecDeque<span style="color:#f92672">&lt;</span>(HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>, Instant)<span style="color:#f92672">&gt;&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> HttpClient<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin <span style="color:#f92672">+</span> Debug <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ::std::error::Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Create a new HttpClient
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">HttpClient</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        HttpClient {
</span></span><span style="display:flex;"><span>            cache_conn: <span style="color:#a6e22e">Arc</span>::new(Mutex::new(LruCache::with_expiry_duration(
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">CONNECTION_EXPIRE_DURATION</span>,
</span></span><span style="display:flex;"><span>            ))),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Make HTTP requests
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>,
</span></span><span style="display:flex;"><span>        stream_map_func: <span style="color:#a6e22e">impl</span> FnOnce(
</span></span><span style="display:flex;"><span>            TcpStream,
</span></span><span style="display:flex;"><span>            AccessLabel,
</span></span><span style="display:flex;"><span>        ) -&gt; <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>TcpStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;</span>, std::io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. Check if there is an available client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(c) <span style="color:#f92672">=</span> self.get_cached_connection(access_label).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP client for host: {} taken from cache&#34;</span>, <span style="color:#f92672">&amp;</span>access_label);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> self.send_request_conn(access_label, c, req).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                Ok(o) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Ok(o),
</span></span><span style="display:flex;"><span>                Err(err) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(io::Error::new(io::ErrorKind::InvalidData, err)),
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. If no. Make a new connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> scheme <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> req.uri().scheme() {
</span></span><span style="display:flex;"><span>            Some(s) <span style="color:#f92672">=&gt;</span> s,
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">&amp;</span>Scheme::<span style="color:#66d9ef">HTTP</span>,
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> HttpConnection::connect(scheme, access_label, stream_map_func).<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>            Ok(c) <span style="color:#f92672">=&gt;</span> c,
</span></span><span style="display:flex;"><span>            Err(err) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">error!</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;failed to connect to host: {}, error: {}&#34;</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>access_label.target, err
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Err(io::Error::new(io::ErrorKind::InvalidData, err));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.send_request_conn(access_label, c, req)
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>            .map_err(<span style="color:#f92672">|</span>e<span style="color:#f92672">|</span> io::Error::new(io::ErrorKind::InvalidData, e))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_cached_connection</span>(<span style="color:#f92672">&amp;</span>self, access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>) -&gt; Option<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(q) <span style="color:#f92672">=</span> self.cache_conn.lock().<span style="color:#66d9ef">await</span>.get_mut(access_label) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;HTTP client for host: {} found in cache, len: {}&#34;</span>,
</span></span><span style="display:flex;"><span>                access_label,
</span></span><span style="display:flex;"><span>                q.len()
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some((c, inst)) <span style="color:#f92672">=</span> q.pop_front() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> now <span style="color:#f92672">=</span> Instant::now();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> now <span style="color:#f92672">-</span> inst <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">CONNECTION_EXPIRE_DURATION</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {} expired&#34;</span>, access_label,);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> c.is_closed() {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// true at once after connection.await return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP connection for host: {} is closed&#34;</span>, access_label,);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Some(c);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">debug!</span>(<span style="color:#e6db74">&#34;HTTP client for host: {} not found in cache&#34;</span>, access_label);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        None
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request_conn</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">mut</span> c: <span style="color:#a6e22e">HttpConnection</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">hyper</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;HTTP making request to host: {}, request: {:?}&#34;</span>,
</span></span><span style="display:flex;"><span>            access_label,
</span></span><span style="display:flex;"><span>            req
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> response <span style="color:#f92672">=</span> c.send_request(req).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;HTTP received response from host: {}, response: {:?}&#34;</span>,
</span></span><span style="display:flex;"><span>            access_label,
</span></span><span style="display:flex;"><span>            response
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check keep-alive
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> check_keep_alive(response.version(), response.headers(), <span style="color:#66d9ef">false</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;HTTP connection keep-alive for host: {}, response: {:?}&#34;</span>,
</span></span><span style="display:flex;"><span>                access_label,
</span></span><span style="display:flex;"><span>                response
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>            self.cache_conn
</span></span><span style="display:flex;"><span>                .lock()
</span></span><span style="display:flex;"><span>                .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>                .entry(access_label.clone())
</span></span><span style="display:flex;"><span>                .or_insert_with(VecDeque::new)
</span></span><span style="display:flex;"><span>                .push_back((c, Instant::now()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(response)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">check_keep_alive</span>(
</span></span><span style="display:flex;"><span>    version: <span style="color:#a6e22e">Version</span>,
</span></span><span style="display:flex;"><span>    headers: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">HeaderMap</span><span style="color:#f92672">&lt;</span>HeaderValue<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    check_proxy: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// HTTP/1.1, HTTP/2, HTTP/3 keeps alive by default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> conn_keep_alive <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">matches!</span>(version, Version::<span style="color:#66d9ef">HTTP_09</span> <span style="color:#f92672">|</span> Version::<span style="color:#66d9ef">HTTP_10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> check_proxy {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Modern browsers will send Proxy-Connection instead of Connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// for HTTP/1.0 proxies which blindly forward Connection to remote
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// https://tools.ietf.org/html/rfc7230#appendix-A.1.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(b) <span style="color:#f92672">=</span> get_keep_alive_val(headers.get_all(<span style="color:#e6db74">&#34;Proxy-Connection&#34;</span>)) {
</span></span><span style="display:flex;"><span>            conn_keep_alive <span style="color:#f92672">=</span> b
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Connection will replace Proxy-Connection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// But why client sent both Connection and Proxy-Connection? That&#39;s not standard!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(b) <span style="color:#f92672">=</span> get_keep_alive_val(headers.get_all(<span style="color:#e6db74">&#34;Connection&#34;</span>)) {
</span></span><span style="display:flex;"><span>        conn_keep_alive <span style="color:#f92672">=</span> b
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    conn_keep_alive
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_keep_alive_val</span>(values: <span style="color:#a6e22e">header</span>::GetAll<span style="color:#f92672">&lt;</span>HeaderValue<span style="color:#f92672">&gt;</span>) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> conn_keep_alive <span style="color:#f92672">=</span> None;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> value <span style="color:#66d9ef">in</span> values {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(value) <span style="color:#f92672">=</span> value.to_str() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> value.eq_ignore_ascii_case(<span style="color:#e6db74">&#34;close&#34;</span>) {
</span></span><span style="display:flex;"><span>                conn_keep_alive <span style="color:#f92672">=</span> Some(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> part <span style="color:#66d9ef">in</span> value.split(<span style="color:#e6db74">&#39;,&#39;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> part <span style="color:#f92672">=</span> part.trim();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> part.eq_ignore_ascii_case(<span style="color:#e6db74">&#34;keep-alive&#34;</span>) {
</span></span><span style="display:flex;"><span>                        conn_keep_alive <span style="color:#f92672">=</span> Some(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    conn_keep_alive
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[allow(dead_code)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">HttpConnection</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Http1(http1::SendRequest<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    B: <span style="color:#a6e22e">Body</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Unpin <span style="color:#f92672">+</span> &#39;static,
</span></span><span style="display:flex;"><span>    B::Data: Send,
</span></span><span style="display:flex;"><span>    B::Error: Into<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ::std::error::Error <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> Sync<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect</span>(
</span></span><span style="display:flex;"><span>        scheme: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Scheme</span>,
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>,
</span></span><span style="display:flex;"><span>        stream_map_func: <span style="color:#a6e22e">impl</span> FnOnce(
</span></span><span style="display:flex;"><span>            TcpStream,
</span></span><span style="display:flex;"><span>            AccessLabel,
</span></span><span style="display:flex;"><span>        ) -&gt; <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>TcpStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">*</span>scheme <span style="color:#f92672">!=</span> Scheme::<span style="color:#66d9ef">HTTP</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>scheme <span style="color:#f92672">!=</span> Scheme::<span style="color:#66d9ef">HTTPS</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Err(io::Error::new(ErrorKind::InvalidInput, <span style="color:#e6db74">&#34;invalid scheme&#34;</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TcpStream::connect(<span style="color:#f92672">&amp;</span>access_label.target).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream: <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>TcpStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            stream_map_func(stream, access_label.clone());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        HttpConnection::connect_http_http1(scheme, access_label, stream).<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">connect_http_http1</span>(
</span></span><span style="display:flex;"><span>        scheme: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Scheme</span>,
</span></span><span style="display:flex;"><span>        access_label: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">AccessLabel</span>,
</span></span><span style="display:flex;"><span>        stream: <span style="color:#a6e22e">CounterIO</span><span style="color:#f92672">&lt;</span>TcpStream, LabelImpl<span style="color:#f92672">&lt;</span>AccessLabel<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>HttpConnection<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">trace!</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;HTTP making new HTTP/1.1 connection to host: {}, scheme: {}&#34;</span>,
</span></span><span style="display:flex;"><span>            access_label,
</span></span><span style="display:flex;"><span>            scheme
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TimeoutIO::new(stream, <span style="color:#66d9ef">CONNECTION_EXPIRE_DURATION</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// HTTP/1.x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> (send_request, connection) <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> http1::Builder::new()
</span></span><span style="display:flex;"><span>            .preserve_header_case(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .title_case_headers(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            .handshake(Box::pin(TokioIo::new(stream)))
</span></span><span style="display:flex;"><span>            .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Ok(s) <span style="color:#f92672">=&gt;</span> s,
</span></span><span style="display:flex;"><span>            Err(err) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(io::Error::new(ErrorKind::Other, err)),
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> access_label <span style="color:#f92672">=</span> access_label.clone();
</span></span><span style="display:flex;"><span>        tokio::spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(err) <span style="color:#f92672">=</span> connection.<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>                handle_http1_connection_error(err, access_label);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        Ok(HttpConnection::Http1(send_request))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[inline]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_request</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self,
</span></span><span style="display:flex;"><span>        req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">hyper</span>::Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>body::Incoming<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.send_request(req).<span style="color:#66d9ef">await</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_closed</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            HttpConnection::Http1(r) <span style="color:#f92672">=&gt;</span> r.is_closed(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">handle_http1_connection_error</span>(err: <span style="color:#a6e22e">hyper</span>::Error, access_label: <span style="color:#a6e22e">AccessLabel</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(source) <span style="color:#f92672">=</span> err.source() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(io_err) <span style="color:#f92672">=</span> source.downcast_ref::<span style="color:#f92672">&lt;</span>io::Error<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> io_err.kind() <span style="color:#f92672">==</span> ErrorKind::TimedOut {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 由于超时导致的连接关闭（TimeoutIO）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">info!</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;[legacy proxy connection io closed]: [{}] {} to {}&#34;</span>,
</span></span><span style="display:flex;"><span>                    io_err.kind(),
</span></span><span style="display:flex;"><span>                    io_err,
</span></span><span style="display:flex;"><span>                    access_label
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">warn!</span>(
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;[legacy proxy io error]: [{}] {} to {}&#34;</span>,
</span></span><span style="display:flex;"><span>                    io_err.kind(),
</span></span><span style="display:flex;"><span>                    io_err,
</span></span><span style="display:flex;"><span>                    access_label
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[legacy proxy io error]: [{}] to {}&#34;</span>, source, access_label);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">warn!</span>(<span style="color:#e6db74">&#34;[legacy proxy io error] [{}] to {}&#34;</span>, err, access_label);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/afterburner-profile/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Afterburner配置文件备份</span>
    </a>
    
    
    <a href="/posts/homebrew-versioned/" class="navigation-next">
      <span class="navigation-tittle">Homebrew安装指定版本的软件</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


        </div>
        
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    




    



    </body>
</html>
