<!DOCTYPE html>
<html lang="zh-CN">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/socks-over-http/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.152.2">

    
    
    

<title>Sogo—使用http协议进行混淆/伪装的socks5代理 • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Sogo—使用http协议进行混淆/伪装的socks5代理">
  <meta name="twitter:description" content="之前写了一个http代理，用起来也是十分地舒服，但是有几个点还是有些遗憾的：
http代理只能代理http协议，相比socks5代理不够通用。。 netty是个好框架，但是java占用内存是真的多。。 所以，我又写了一个socks5代理，起名叫sogo。
sogo本身包含sogo(client)和sogo-server。如果把sogo和sogo-server看成一个整体，一个黑盒，这个整体就是一个socks5代理。sogo(client)与本地电脑交互；sogo-server与目标网站交互；sogo(client)和sogo-server之间的交互就是http协议包裹payload进行通信。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/socks-over-http/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Sogo—使用http协议进行混淆/伪装的socks5代理">
  <meta property="og:description" content="之前写了一个http代理，用起来也是十分地舒服，但是有几个点还是有些遗憾的：
http代理只能代理http协议，相比socks5代理不够通用。。 netty是个好框架，但是java占用内存是真的多。。 所以，我又写了一个socks5代理，起名叫sogo。
sogo本身包含sogo(client)和sogo-server。如果把sogo和sogo-server看成一个整体，一个黑盒，这个整体就是一个socks5代理。sogo(client)与本地电脑交互；sogo-server与目标网站交互；sogo(client)和sogo-server之间的交互就是http协议包裹payload进行通信。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-04-10T14:24:10+08:00">
    <meta property="article:modified_time" content="2019-04-10T14:24:10+08:00">
    <meta property="article:tag" content="Undefined">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.484b96856b25751067d56c8c0af9dc1fd6372707029b6d56ee178da6bead45b5.css" integrity="sha256-SEuWhWsldRBn1WyMCvncH9Y3JwcCm21W7heNpr6tRbU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.0873834b0f2e9fdc9e1d0301e8ebce21fc10383882a41e9373f29b90e85a9987.css" integrity="sha256-CHODSw8un9yeHQMB6OvOIfwQODiCpB6Tc/KbkOhamYc=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana/d/a0d0b2fe-285a-44ba-8509-a404961d6da49/rust-http-proxy">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="http://beian.miit.gov.cn/">
						<span>沪ICP备2025110448号</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    
<div class="copyright">
  &copy; 2025 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>
        <div class="content container">
            
    
<article>
  <header>
    <h1>Sogo—使用http协议进行混淆/伪装的socks5代理</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Apr 10, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/undefined">UNDEFINED</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/undefined">undefined</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 14 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#特性">特性</a></li>
    <li><a href="#处理socks5握手对socks5协议的实现">处理socks5握手——对socks5协议的实现</a></li>
    <li><a href="#使用http包裹payload">使用http包裹payload</a></li>
    <li><a href="#解包伪装好的请求响应">解包伪装好的请求、响应</a></li>
    <li><a href="#伪装sogo-server80为其他http网站">伪装sogo-server:80为其他http网站</a></li>
    <li><a href="#linux上服务端部署">linux上服务端部署</a></li>
    <li><a href="#linux上客户端安装java版">linux上客户端安装（java版）</a></li>
    <li><a href="#linux上客户端安装过时">linux上客户端安装（过时）</a></li>
    <li><a href="#windows客户端安装">windows客户端安装</a></li>
    <li><a href="#写sogo有感">写Sogo有感</a></li>
    <li><a href="#维护日志">维护日志</a>
      <ul>
        <li><a href="#1因byte未复用导致频繁gc从而cpu占用夸张">1.因[]byte未复用，导致频繁GC，从而cpu占用夸张</a></li>
        <li><a href="#2因为频繁写入日志文件导致cpu-iowait过高">2.因为频繁写入日志文件，导致cpu iowait过高</a></li>
        <li><a href="#3报错too-many-open-files">3.报错：too many open files</a></li>
      </ul>
    </li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>之前写了一个http代理，用起来也是十分地舒服，但是有几个点还是有些遗憾的：</p>
<ul>
<li>http代理只能代理http协议，相比socks5代理不够通用。。</li>
<li>netty是个好框架，但是java占用内存是真的多。。</li>
</ul>
<p>所以，我又写了一个socks5代理，起名叫<a href="https://github.com/arloor/sogo">sogo</a>。</p>
<p>sogo本身包含sogo(client)和sogo-server。如果把sogo和sogo-server看成一个整体，一个黑盒，这个整体就是一个socks5代理。sogo(client)与本地电脑交互；sogo-server与目标网站交互；sogo(client)和sogo-server之间的交互就是http协议包裹payload进行通信。</p>
<h2 id="特性">特性</h2>
<p>sogo项目最好的两个特性如下：</p>
<ol>
<li>使用http包裹payload(有意义的数据)。</li>
<li>将sogo-server所在的ip:端口伪装成一个http网站。</li>
</ol>
<p>效用、坚固、美观——对软件产品的三个要求。上面两个特性，既可以说是坚固，也可以说是美观，至于效用就不用说了，在这里谈坚固和美观的前提就是效用被完整地实现。用通俗地话来说，这个代理的坚固和美观就是：伪装、防止被识别。</p>
<h2 id="处理socks5握手对socks5协议的实现">处理socks5握手——对socks5协议的实现</h2>
<p>sogo(client)与本地电脑交互，因此需要实现socks5协议，与本地用户（比如chrome）握手协商。</p>
<p>一个典型的sock5握手的顺序：</p>
<ol>
<li>client：0x05 0x01 0x00</li>
<li>proxy: 0x05 0x00</li>
<li>client: 0x05 0x01 0x00 0x01 ip1 ip2 ip3 ip4 0x00 0x50</li>
<li>proxy: 0x05 0x00 0x00 0x01 0x00 0x00 0x00 0x00 0x10 0x10</li>
<li>proxy盲转发client与server之间的流量</li>
</ol>
<p>这一部分代码见如下两个函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//file: sogo/main.go</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//读 5 1 0 写回 5 0</span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">handshake</span>(clientCon net.<span style="color:#a6e22e">Conn</span>) error {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> buf <span style="color:#f92672">=</span> make(<span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>, 300)
</span></span><span style="display:flex;"><span>	numRead, err :<span style="color:#f92672">=</span> clientCon.<span style="color:#a6e22e">Read</span>(buf)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> err <span style="color:#f92672">!=</span> nil {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> numRead <span style="color:#f92672">==</span> 3 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X05 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X01 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X00 {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> mio.<span style="color:#a6e22e">WriteAll</span>(clientCon, <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>{0x05, 0x00})
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, buf<span style="color:#f92672">[</span>:numRead<span style="color:#f92672">]</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> mio.<span style="color:#a6e22e">WriteAll</span>(clientCon, <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>{0x05, 0x00})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">getTargetAddr</span>(clientCon net.<span style="color:#a6e22e">Conn</span>) (string, error) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> buf <span style="color:#f92672">=</span> make(<span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>, 1024)
</span></span><span style="display:flex;"><span>	numRead, err :<span style="color:#f92672">=</span> clientCon.<span style="color:#a6e22e">Read</span>(buf)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> err <span style="color:#f92672">!=</span> nil {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, err
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> numRead <span style="color:#f92672">&gt;</span> 3 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X05 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X01 <span style="color:#f92672">&amp;&amp;</span> buf<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 0X00 {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> buf<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 3 {
</span></span><span style="display:flex;"><span>			log.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;目的地址类型:%d 域名长度:%d 目标域名:%s 目标端口:%s&#34;</span>, buf<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>5:5<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]]</span>, strconv.<span style="color:#a6e22e">Itoa</span>(<span style="color:#66d9ef">int</span>(binary.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">Uint16</span>(buf<span style="color:#f92672">[</span>5<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>:7<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]]</span>))))
</span></span><span style="display:flex;"><span>			writeErr :<span style="color:#f92672">=</span> mio.<span style="color:#a6e22e">WriteAll</span>(clientCon, <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10})
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> string(buf<span style="color:#f92672">[</span>5:5<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]]</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> strconv.<span style="color:#a6e22e">Itoa</span>(<span style="color:#66d9ef">int</span>(binary.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">Uint16</span>(buf<span style="color:#f92672">[</span>5<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>:7<span style="color:#f92672">+</span>buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]]</span>))), writeErr
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> buf<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> 1 {
</span></span><span style="display:flex;"><span>			log.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;目的地址类型:%d  目标域名:%s 目标端口:%s&#34;</span>, buf<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>, net.<span style="color:#a6e22e">IPv4</span>(buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>).<span style="color:#a6e22e">String</span>(), strconv.<span style="color:#a6e22e">Itoa</span>(<span style="color:#66d9ef">int</span>(binary.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">Uint16</span>(buf<span style="color:#f92672">[</span>8:10<span style="color:#f92672">]</span>))))
</span></span><span style="display:flex;"><span>			writeErr :<span style="color:#f92672">=</span> mio.<span style="color:#a6e22e">WriteAll</span>(clientCon, <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10})
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> net.<span style="color:#a6e22e">IPv4</span>(buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>, buf<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>).<span style="color:#a6e22e">String</span>() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">+</span> strconv.<span style="color:#a6e22e">Itoa</span>(<span style="color:#66d9ef">int</span>(binary.<span style="color:#a6e22e">BigEndian</span>.<span style="color:#a6e22e">Uint16</span>(buf<span style="color:#f92672">[</span>8:10<span style="color:#f92672">]</span>))), writeErr
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, errors.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;不能处理ipv6&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, errors.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;不能处理非CONNECT请求&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>完成handshake, getTargetAddr 之后，chrome就会发送真实的http请求了，sogo(client) 要做的就是将这部分http请求进行加密，然后加上http请求的头，发送到sogo-server。</p>
<h2 id="使用http包裹payload">使用http包裹payload</h2>
<p>第一部分：如何将真实的http请求，再进行加密，最后加上假的http请求头，变成伪装好的http请求，发送给sogo-server。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//file: sogo/mio/prefix.go</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> fakeHost <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;qtgwuehaoisdhuaishdaisuhdasiuhlassjd.com&#34;</span>  <span style="color:#75715e">//虚假host</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">AppendHttpRequestPrefix</span>(buf <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>, addr string) <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	Simple(<span style="color:#f92672">&amp;</span>buf, len(buf))<span style="color:#75715e">//对真实的http请求的简单加密</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 演示base64编码</span>
</span></span><span style="display:flex;"><span>	addrBase64 :<span style="color:#f92672">=</span> base64.<span style="color:#a6e22e">NewEncoding</span>(<span style="color:#e6db74">&#34;abcdefghijpqrzABCKLMNOkDEFGHIJl345678mnoPQRSTUVstuvwxyWXYZ0129+/&#34;</span>).<span style="color:#a6e22e">EncodeToString</span>(<span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>(addr))
</span></span><span style="display:flex;"><span>	buf <span style="color:#f92672">=</span> append(<span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>(<span style="color:#e6db74">&#34;POST /target?at=&#34;</span><span style="color:#f92672">+</span>addrBase64<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; HTTP/1.1\r\nHost: &#34;</span><span style="color:#f92672">+</span>fakeHost<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;\r\nAccept: */*\r\nContent-Type: text/plain\r\naccept-encoding: gzip, deflate\r\ncontent-length: &#34;</span><span style="color:#f92672">+</span>strconv.<span style="color:#a6e22e">Itoa</span>(len(buf))<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;\r\n\r\n&#34;</span>), buf...)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> buf
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>包裹完毕之后返回的[]byte就可以发送给sogo-server了。</p>
<p>第二部分：将sogo-server从目标网站获得的真实响应进行简单加密，包裹http响应头，发送给sogo(client)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//file: sogo-server/mio/prefix.go</span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">AppendHttpResponsePrefix</span>(buf <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>) <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	Simple(<span style="color:#f92672">&amp;</span>buf, len(buf))
</span></span><span style="display:flex;"><span>	buf <span style="color:#f92672">=</span> append(<span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>(<span style="color:#e6db74">&#34;HTTP/1.1 200 OK\r\nContent-Type: text/plain; charset=utf-8\r\nContent-Length: &#34;</span><span style="color:#f92672">+</span>strconv.<span style="color:#a6e22e">Itoa</span>(len(buf))<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;\r\n\r\n&#34;</span>), buf...)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> buf
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>包裹完毕之后返回的[]byte就可以发送给sogo(client)了。</p>
<h2 id="解包伪装好的请求响应">解包伪装好的请求、响应</h2>
<p>先看以下伪装好的请求的样子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST /target?at<span style="color:#f92672">={</span>targetAddrBase64<span style="color:#f92672">}</span> HTTP/1.1
</span></span><span style="display:flex;"><span>Host: <span style="color:#f92672">{</span>fakehost<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>Accept: */*
</span></span><span style="display:flex;"><span>Content-Type: text/plain
</span></span><span style="display:flex;"><span>accept-encoding: gzip, deflate
</span></span><span style="display:flex;"><span>content-length: <span style="color:#f92672">{</span>content-length<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>payload-after-crypto<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>sogo-server拿到这个伪装好的请求，要做的事有：</p>
<ol>
<li>获取{targetAddrBase64}，拿到真实的目标网站地址</li>
<li>获取请求头的Host字段，如果不是定义好的fakehost，则说明是直接访问sogo-server，这时sogo-server就是个到混淆网站的反向代理（这就是之前提到的第二个特性。下面将会详细解释如何实现</li>
<li>获取{content-length}，根据这个content-length确定payload部分的长度。</li>
<li>读取指定长度的payload，解密，并创建到targetAddr的连接，转发至targetAddr</li>
</ol>
<p>这些步骤很明确吧。其实有一些细节，挺麻烦的。</p>
<p>tcp是面向流的协议，也就是会有很多个连续的上面的片段，要合理划分出这些片段。有些人称这个为解决“tcp粘包”，谷歌tcp粘包就能搜到如何实现这个需求。但是注意，不要称这个为“tcp粘包”，别人会说tcp是面向流的协议，哪来什么包，你知识体系有问题，你看过tcp协议没有。这些话都是知乎上某一问题的答案说的。所以，别说“tcp粘包”，但是可以用这个关键词去搜索如何解决这个问题。</p>
<p>如果，现在你看了如何解决这个问题，其实就是一句话，在tcp上层定义自己的应用层协议：也就是tcp报文的格式。http这个应用层协议就是一种tcp报文的一种定义。</p>
<p>我们的伪装好的报文就是http协议，所以要做的就是实现自己的http请求解析器，获取我们关心的信息。</p>
<p>sogo的http请求解析器，在：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//file sogo-server/server.go</span>
</span></span><span style="display:flex;"><span>func <span style="color:#a6e22e">read</span>(clientConn net.<span style="color:#a6e22e">Conn</span>, redundancy <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>) (payload, redundancyRetain <span style="color:#f92672">[]</span><span style="color:#66d9ef">byte</span>, target string, readErr error)
</span></span></code></pre></div><p>这一部分有点繁杂。。不多解释，自己看代码吧。</p>
<h2 id="伪装sogo-server80为其他http网站">伪装sogo-server:80为其他http网站</h2>
<p>这一部分就是第二特性：将sogo-server所在的ip:端口伪装成一个http网站。</p>
<p>上一节，我们提到 {fakehost}。我们故意将{fakehost}定义为一个复杂、很长的域名。我们伪装的请求，都会带有如下请求头</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Host: <span style="color:#f92672">{</span>fakehost<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>如果，http请求的Host不是这个{fakehost}则说明这不是一个经sogo(client)的请求，而是直接请求了sogo-server。也就是，有人来嗅探啦！</p>
<p>对这种，我们就会将该请求，原封不动地转到伪装站。（其实还是有点修改的，但这是细节，看代码吧）所以，直接访问sogo-server-ip:80 就是访问伪装站：80。</p>
<h2 id="linux上服务端部署">linux上服务端部署</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install -y wget
</span></span><span style="display:flex;"><span>wget https://github.com/arloor/sogo/releases/download/v1.0/sogo-server
</span></span><span style="display:flex;"><span>wget https://github.com/arloor/sogo/releases/download/v1.0/sogo-server.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>chmod +x sogo-server
</span></span><span style="display:flex;"><span>mv -f sogo-server /usr/local/bin/
</span></span><span style="display:flex;"><span>mv -f sogo-server.json /usr/local/bin/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#创建service</span>
</span></span><span style="display:flex;"><span>cat &gt; /lib/systemd/system/sogo-server.service <span style="color:#e6db74">&lt;&lt;EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Unit]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Description=sogo-server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">After=network-online.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Wants=network-online.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Service]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Type=simple
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">WorkingDirectory=/root/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">ExecStart=/usr/local/bin/sogo-server
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">LimitNOFILE=100000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Restart=always
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">RestartSec=5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Install]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">WantedBy=multi-user.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>service  sogo-server start
</span></span><span style="display:flex;"><span>systemctl daemon-reload
</span></span><span style="display:flex;"><span>systemctl enable sogo-server
</span></span></code></pre></div><h2 id="linux上客户端安装java版">linux上客户端安装（java版）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget --no-check-certificate --no-cookies --header <span style="color:#e6db74">&#34;Cookie: oraclelicense=accept-securebackup-cookie&#34;</span> http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm
</span></span><span style="display:flex;"><span><span style="color:#75715e">#wget http://repo-1252282974.cossh.myqcloud.com/jdk-8u131-linux-x64.rpm #使用腾讯云对象存储</span>
</span></span><span style="display:flex;"><span>rpm -ivh jdk-8u131-linux-x64.rpm
</span></span><span style="display:flex;"><span>rm -f jdk-8u131-linux-x64.rpm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mkdir socks5
</span></span><span style="display:flex;"><span>cd socks5
</span></span><span style="display:flex;"><span>wget http://repo-1252282974.cossh.myqcloud.com/sogo.jar
</span></span><span style="display:flex;"><span>wget http://repo-1252282974.cossh.myqcloud.com/sogo.json
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#创建service</span>
</span></span><span style="display:flex;"><span>cat &gt; /lib/systemd/system/sogo.service <span style="color:#e6db74">&lt;&lt;EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Unit]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Description=一个socks5代理
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Service]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Restart=always
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">WorkingDirectory=/root/socks5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">ExecStart=/usr/bin/java -jar /root/socks5/sogo.jar -c /root/socks5/sogo.json
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">LimitNOFILE=100000
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Restart=always
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">RestartSec=2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Install]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">WantedBy=multi-user.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl daemon-reload
</span></span><span style="display:flex;"><span>systemctl enable sogo
</span></span><span style="display:flex;"><span>systemctl start sogo
</span></span><span style="display:flex;"><span><span style="color:#75715e">#vim /etc/hosts #配置proxy1 proxy2</span>
</span></span></code></pre></div><h2 id="linux上客户端安装过时">linux上客户端安装（过时）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 国内机器下面两个wget会很慢，考虑本地下载再上传到服务器吧</span>
</span></span><span style="display:flex;"><span>wget https://github.com/arloor/sogo/releases/download/v1.0/sogo.json
</span></span><span style="display:flex;"><span>wget https://github.com/arloor/sogo/releases/download/v1.0/sogo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>chmod +x sogo
</span></span><span style="display:flex;"><span>mv -f sogo /usr/local/bin/
</span></span><span style="display:flex;"><span>mv -f sogo.json /usr/local/bin/
</span></span><span style="display:flex;"><span>kill -9 <span style="color:#66d9ef">$(</span>ps -aux|grep -v <span style="color:#e6db74">&#34;grep&#34;</span>|grep sogo|awk <span style="color:#e6db74">&#39;$1!=&#34;&#34;{print $2}&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>ulimit -n <span style="color:#ae81ff">65536</span> <span style="color:#75715e">#设置进程最多打开文件数量，防止 too many openfiles错误（太多连接</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 运行前，先修改/usr/local/bin/sogo.json</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>sogo &amp;<span style="color:#f92672">)</span> <span style="color:#75715e">#以 /usr/local/bin/sogo.json 为配置文件  该配置下，服务端地址被设置为proxy</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#(sogo -c path &amp;)  #以path指向的文件为配置文件</span>
</span></span></code></pre></div><h2 id="windows客户端安装">windows客户端安装</h2>
<p>到<a href="https://github.com/arloor/sogo/releases/tag/v1.0">Release</a>下载<code>sogo.exe</code>和<code>sogo.json</code>。</p>
<p>sogo.json内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;ClientPort&#34;</span>: <span style="color:#ae81ff">8888</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;Use&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;Servers&#34;</span>: [
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;ProxyAddr&#34;</span>: <span style="color:#e6db74">&#34;proxy&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;ProxyPort&#34;</span>: <span style="color:#ae81ff">80</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;UserName&#34;</span>: <span style="color:#e6db74">&#34;a&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;Password&#34;</span>: <span style="color:#e6db74">&#34;b&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  ],
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;Dev&#34;</span>:<span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先修改<code>ProxyAddr</code>为服务端安装的地址即可。其他配置项是高级功能，例如多服务器管理，多用户管理（用户认证）等等。</p>
<blockquote>
<p>shadowsocks是没有多用户管理的，ss每个端口对应一个用户。sogo则使用用户名+密码认证，使多个用户使用同一个服务器端口。</p>
</blockquote>
<p>修改好之后，双击<code>sogo.exe</code>，这时会发现该目录下多了一个 sogo_8888.log 的文件，这就说明，在本地的8888端口启动好了这个sock5代理。（没有界面哦。</p>
<h2 id="写sogo有感">写Sogo有感</h2>
<p>sogo代码不多，对go语言、网络编程感兴趣的人可以看看。这篇博客梳理了一下sogo的实现原理，总之，sogo是一个优雅的代理。</p>
<p>机缘巧合之下，sogo刚好满足了一家公司业务的需要，于是刚刚写好就投入了使用。</p>
<img src="/img/earn-money-start.jpg" alt="" width="500px" style="max-width: 100%;">

<p>就是这样，sogo意外地成为我的第一个“有别人愿意用”的作品，并且收到了实际的回报。从后来的了解来看，sogo解决了他们业务的重大痛点。他们的软件是第三方telegram，用于聊天挖矿（我不懂），并且内部封装socks5代理的配置来连接电报服务器，从而免去用户自己寻找电报代理。之前都是使用网上找的公开socks5代理隔几天就挂完。翻看他们的群组通知，好多条都是说，“连接服务器有问题，正在解决，抱歉”，直到有了sogo！可以说sogo现在是他们这个软件很重要的一个基础设施。（不吹能死吗？</p>
<p>所以呀，钱要少了。不过本来就没想赚钱，有总比没有好对吧。另一方面，这也是对我的技术能力的认可。嗯，这才是最重要的吧，挺爽的。以前写的东西没人用，后来写的东西自己用，现在写的东西别人买来用，境界就不一样啦。用三个词概括一下这段经历吧：机缘巧合😱、钱要少了😭、得到认可😄。</p>
<img src="/img/talk-about-payment.jpg" alt="" width="500px" style="max-width: 100%;">

<p>放一张服务器的运行状况监控证明一下有人用😂。如下图的监控所示，服务器的带宽和tcp连接数量都保持在稳定的水平。tcp连接数较多，但是带宽不大，这也符合文字内容传输的使用场景。</p>
<p><img src="/img/monitor-aliyun.png" alt=""></p>
<p>24小时的带宽占用如下，夜深人静的时候最低，可以说很真实了</p>
<p><img src="/img/bandwagon-daikuan.jpg" alt=""></p>
<p>废话说得够啦，最后来听听歌吧。 Something just like this 😍</p>


<div class="iframe-container">
    <iframe src="https://www.youtube.com/embed/-SgyhUdJ_TY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2 id="维护日志">维护日志</h2>
<h3 id="1因byte未复用导致频繁gc从而cpu占用夸张">1.因[]byte未复用，导致频繁GC，从而cpu占用夸张</h3>
<p>在带宽达到50M时，cpu占用达到夸张的50%。想想实现，就知道时内存没有复用导致频繁GC，所以就想弄个内存池出来，本来想自己实现，后来发现GO语言有sync.pool满足这个临时对象池的需求。</p>
<h3 id="2因为频繁写入日志文件导致cpu-iowait过高">2.因为频繁写入日志文件，导致cpu iowait过高</h3>
<p>从监控来看，cpu占用达到夸张的90%，使用top命令看到cpu的iowait有70%多。</p>
<p>iowait是cpu等待io的时间占比，sogo应用是网络IO，一般不会有磁盘IO，唯一有可能的只有写入日志文件。在关闭日志记录之后，cpu iowait降低至0，问题解决。</p>
<p>一些排查iowait占用高的方法：</p>
<h4 id="查找哪个硬盘正在被写入">查找哪个硬盘正在被写入</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@coolnull ~<span style="color:#f92672">]</span><span style="color:#75715e"># iostat -x 2 5</span>
</span></span><span style="display:flex;"><span> avg-cpu: %user %nice %system %iowait %steal %idle
</span></span><span style="display:flex;"><span>  3.66 0.00 47.64 48.69 0.00 0.00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
</span></span><span style="display:flex;"><span> sda 44.50 39.27 117.28 29.32 11220.94 13126.70 332.17 65.77 462.79 9.80 2274.71 7.60 111.41
</span></span><span style="display:flex;"><span> dm-0 0.00 0.00 83.25 9.95 10515.18 4295.29 317.84 57.01 648.54 16.73 5935.79 11.48 107.02
</span></span><span style="display:flex;"><span> dm-1 0.00 0.00 57.07 40.84 228.27 163.35 8.00 93.84 979.61 13.94 2329.08 10.93 107.02
</span></span></code></pre></div><p>上述示例的iostat命令将每2秒打印出报告，共打印5次；-x参数告诉iostata打印出更详尽的报告</p>
<p>iostat打印出的第1个报告，数值是基于最后一次系统启动的时间统计的；基于这个原因，在大部份情况下，iostat打印出的第1个报告应该被忽略。每个子报告都是基于上1次的报告。在这个例子中，我们的命令将打印5次报告，第2份报告就是从第1份报告开始后的硬盘数据，第3份报告基于第2份，依此类推。</p>
<p>上述示例，sda盘的%utilized达到了111.41%。这表示引起I/O慢的进程在写入sda盘。因为我这个测试实例中只有1个硬盘，但对于有多硬盘的服务器来说，这可以缩小在使用I/O的进程范围。</p>
<p>除了iostat的%utilized能提供丰富的信息外，像rrqm/s、wrqm/s这些每秒读、写的请求数，r/s、w/s每秒读写数也很有用。在我们的例子中，我们的程序看起来读写很繁重的信息也能帮助我们确定这个讨人厌的进程。</p>
<h4 id="查找引起高io的进程">查找引起高I/O的进程</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@coolnull ~<span style="color:#f92672">]</span><span style="color:#75715e"># iotop</span>
</span></span><span style="display:flex;"><span> Total DISK READ: 8.00 M/s | Total DISK WRITE: 20.36 M/s
</span></span><span style="display:flex;"><span>  TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">15758</span> be/4 root 7.99 M/s 8.01 M/s 0.00 % 61.97 % bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span></code></pre></div><p>查看哪个进程使用硬盘最多的最简单的方法就是使用iotop命令。通过查看数据，我们很容易就能确定是bonnie++这个进程引起我们机器高I/O</p>
<p>虽然iotop好用，但默认主流的linux发行版中是没有安装的；并且我个人也不推荐依赖默认系统没有安装的命令。系统管理员总是会碰到这样的情况，他们没办法在短时间内简单地安装这些非默认包。</p>
<p>如果iotop没办法用，以下的步聚还是可以帮助你缩小这些讨人厌进程的范围</p>
<h4 id="进程状态列表">进程状态列表</h4>
<p>ps命令能打印出内存，cpu的情况但没办法打印出硬盘I/O的情况。虽然ps没办法打印出I/O的情况，但它可以显示出进程是否在等待I/O。</p>
<p>The ps state field provides the processes current state; below is a list of states from the man page.
ps状态列提供了进程当前的状态，以下从man ps上获取的进程stat列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PROCESS STATE CODES
</span></span><span style="display:flex;"><span> D uninterruptible sleep <span style="color:#f92672">(</span>usually IO<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> R running or runnable <span style="color:#f92672">(</span>on run queue<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> S interruptible sleep <span style="color:#f92672">(</span>waiting <span style="color:#66d9ef">for</span> an event to complete<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> T stopped, either by a job control signal or because it is being traced.
</span></span><span style="display:flex;"><span> W paging <span style="color:#f92672">(</span>not valid since the 2.6.xx kernel<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> X dead <span style="color:#f92672">(</span>should never be seen<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> Z defunct <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;zombie&#34;</span><span style="color:#f92672">)</span> process, terminated but not reaped by its parent.
</span></span></code></pre></div><p>等待I/O的进程通过处于uninterruptible sleep或D状态；通过给出这些信息我们就可以简单的查找出处在wait状态的进程</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@coolnull ~<span style="color:#f92672">]</span><span style="color:#75715e"># for x in `seq 1 1 10`; do ps -eo state,pid,cmd | grep &#34;^D&#34;; echo &#34;----&#34;; sleep 5; done</span>
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">248</span> <span style="color:#f92672">[</span>jbd2/dm-0-8<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">16528</span> bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span><span style="display:flex;"><span> ----
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">22</span> <span style="color:#f92672">[</span>kswapd0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">16528</span> bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span><span style="display:flex;"><span> ----
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">22</span> <span style="color:#f92672">[</span>kswapd0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">16528</span> bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span><span style="display:flex;"><span> ----
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">22</span> <span style="color:#f92672">[</span>kswapd0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">16528</span> bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span><span style="display:flex;"><span> ----
</span></span><span style="display:flex;"><span> D <span style="color:#ae81ff">16528</span> bonnie++ -n <span style="color:#ae81ff">0</span> -u <span style="color:#ae81ff">0</span> -r <span style="color:#ae81ff">239</span> -s <span style="color:#ae81ff">478</span> -f -b -d /tmp
</span></span><span style="display:flex;"><span> ----
</span></span></code></pre></div><p>上述命令会每5秒循环打印出位于D状态的进程，共打印10次</p>
<p>从上面的输出可以看出bonnie++，pid 16528比其它进程更加占用I/O。从这点，bonnie++看起来更有可能引起I/O Wait。但仅凭进程处于uninterruptible sleep state誊，还不能完全确定就是这引起的I/O wait。</p>
<p>为了帮助肯定我们的怀疑，我们可以使用/proc文件系统。在这个进程目录里，每个进程都有一个io文件，里面的数值跟iotop命令获取的I/O数值一样。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@coolnull ~<span style="color:#f92672">]</span><span style="color:#75715e"># cat /proc/16528/io</span>
</span></span><span style="display:flex;"><span> rchar: <span style="color:#ae81ff">48752567</span>
</span></span><span style="display:flex;"><span> wchar: <span style="color:#ae81ff">549961789</span>
</span></span><span style="display:flex;"><span> syscr: <span style="color:#ae81ff">5967</span>
</span></span><span style="display:flex;"><span> syscw: <span style="color:#ae81ff">67138</span>
</span></span><span style="display:flex;"><span> read_bytes: <span style="color:#ae81ff">49020928</span>
</span></span><span style="display:flex;"><span> write_bytes: <span style="color:#ae81ff">549961728</span>
</span></span><span style="display:flex;"><span> cancelled_write_bytes: <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>read_bytes和write_bytes就这个进程读写硬盘的字节数。在这里，bonnie++已经读取了46MB，写入524MB的数据。对很多进程，这可能不是很多，但在我们这个实例这足够引起高i/o wait。</p>
<h4 id="查找哪个文件在被繁重地写入">查找哪个文件在被繁重地写入</h4>
<p>lsof命令会为你展示指定进程打开的所有文件或依赖提供选项的所有进程。从这个列表，人们可以根据文件的大小和/proc io文件里出现的次数做出有用的猜测，哪个文件正在被频繁地写入。</p>
<p>为了减少输出的内容，我们可以使用-p 选项来只打印指定进程id打开的文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@coolnull ~<span style="color:#f92672">]</span><span style="color:#75715e"># lsof -p 16528</span>
</span></span><span style="display:flex;"><span> COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root cwd DIR 252,0 <span style="color:#ae81ff">4096</span> <span style="color:#ae81ff">130597</span> /tmp
</span></span><span style="display:flex;"><span> &lt;truncated&gt;
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root 8u REG 252,0 <span style="color:#ae81ff">501219328</span> <span style="color:#ae81ff">131869</span> /tmp/Bonnie.16528
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root 9u REG 252,0 <span style="color:#ae81ff">501219328</span> <span style="color:#ae81ff">131869</span> /tmp/Bonnie.16528
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root 10u REG 252,0 <span style="color:#ae81ff">501219328</span> <span style="color:#ae81ff">131869</span> /tmp/Bonnie.16528
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root 11u REG 252,0 <span style="color:#ae81ff">501219328</span> <span style="color:#ae81ff">131869</span> /tmp/Bonnie.16528
</span></span><span style="display:flex;"><span> bonnie++ <span style="color:#ae81ff">16528</span> root 12u REG 252,0 <span style="color:#ae81ff">501219328</span> <span style="color:#ae81ff">131869</span> &lt;strong&gt;/tmp/Bonnie.16528
</span></span></code></pre></div><h3 id="3报错too-many-open-files">3.报错：too many open files</h3>
<p>错误日志如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Socket accept error: accept tcp <span style="color:#f92672">[</span>::<span style="color:#f92672">]</span>:80: accept4: too many open files;
</span></span></code></pre></div><p>too many open files(打开的文件过多)是Linux系统中常见的错误，从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，也包括打开的通讯链接(比如socket)，正在监听的端口等等，所以有时候也可以叫做句柄(handle)，这个错误通常也可以叫做句柄数超出系统限制。</p>
<p>引起的原因就是进程在某个时刻打开了超过shell会话限制的文件数量以及通讯链接数，通过命令<code>ulimit -a</code>可以查看当前shell会话设置的最大句柄数是多少</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ulimit -a</span>
</span></span><span style="display:flex;"><span>core file size          <span style="color:#f92672">(</span>blocks, -c<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>data seg size           <span style="color:#f92672">(</span>kbytes, -d<span style="color:#f92672">)</span> unlimited
</span></span><span style="display:flex;"><span>scheduling priority             <span style="color:#f92672">(</span>-e<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>file size               <span style="color:#f92672">(</span>blocks, -f<span style="color:#f92672">)</span> unlimited
</span></span><span style="display:flex;"><span>pending signals                 <span style="color:#f92672">(</span>-i<span style="color:#f92672">)</span> <span style="color:#ae81ff">14732</span>
</span></span><span style="display:flex;"><span>max locked memory       <span style="color:#f92672">(</span>kbytes, -l<span style="color:#f92672">)</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>max memory size         <span style="color:#f92672">(</span>kbytes, -m<span style="color:#f92672">)</span> unlimited
</span></span><span style="display:flex;"><span>open files                      <span style="color:#f92672">(</span>-n<span style="color:#f92672">)</span> <span style="color:#ae81ff">1024</span>  <span style="color:#75715e">#太小了，可以直接改到65536</span>
</span></span><span style="display:flex;"><span>pipe size            <span style="color:#f92672">(</span><span style="color:#ae81ff">512</span> bytes, -p<span style="color:#f92672">)</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>POSIX message queues     <span style="color:#f92672">(</span>bytes, -q<span style="color:#f92672">)</span> <span style="color:#ae81ff">819200</span>
</span></span><span style="display:flex;"><span>real-time priority              <span style="color:#f92672">(</span>-r<span style="color:#f92672">)</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>stack size              <span style="color:#f92672">(</span>kbytes, -s<span style="color:#f92672">)</span> <span style="color:#ae81ff">10240</span>
</span></span><span style="display:flex;"><span>cpu time               <span style="color:#f92672">(</span>seconds, -t<span style="color:#f92672">)</span> unlimited
</span></span><span style="display:flex;"><span>max user processes              <span style="color:#f92672">(</span>-u<span style="color:#f92672">)</span> <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>virtual memory          <span style="color:#f92672">(</span>kbytes, -v<span style="color:#f92672">)</span> unlimited
</span></span><span style="display:flex;"><span>file locks                      <span style="color:#f92672">(</span>-x<span style="color:#f92672">)</span> unlimited
</span></span></code></pre></div><p>open files那一行就代表当前shell会话目前允许单个进程打开的最大句柄数，这里是1024，这个值对于这个使用场景太小了。</p>
<p>使用命令lsof -p 进程id可以查看单个进程所有打开的文件详情，使用命令lsof -p 进程id | wc -l可以统计进程打开了多少文件：（PS：使用lsof -i:80|wc -l可以查看80端口有多少个连接）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>lsof -p <span style="color:#66d9ef">$(</span>ps -aux|grep -v <span style="color:#e6db74">&#34;grep&#34;</span>|grep sogo|awk <span style="color:#e6db74">&#39;$1!=&#34;&#34;{print $2}&#39;</span><span style="color:#66d9ef">)</span>|wc -l
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1610</span>
</span></span><span style="display:flex;"><span>lsof -i:80|wc -l
</span></span><span style="display:flex;"><span><span style="color:#75715e">#337</span>
</span></span></code></pre></div><p>问题定位到这个limit过低，解决自然就是增加这个limit。最最简单的方法是执行以下脚本，增加当前shell和它的子进程的limit，然后重启进程。</p>
<pre tabindex="0"><code>ulimit -n 65536
</code></pre><blockquote>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。前面多次提到shell会话，ulimit的影响范围是，输入ulimit命令之后的命令，也就是对当前shell和当前shell的子进程生效，对其它shell不产生影响。</p>
</blockquote>
<p>重启进程后，可以执行以下命令，查看新的limit是否对新进程生效</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /proc/$pid/limits|grep open
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Max open files            65536                65536                files</span>
</span></span></code></pre></div><p>另一种，通过修改配置文件来修改limit，在重启后不会失效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vim /etc/security/limits.conf  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#在最后加入  </span>
</span></span><span style="display:flex;"><span>* soft nofile <span style="color:#ae81ff">65536</span>  
</span></span><span style="display:flex;"><span>* hard nofile <span style="color:#ae81ff">65536</span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#或者只加入：</span>
</span></span><span style="display:flex;"><span>* - nofile <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 星号表示所有用户，也可以写用户名，对单独用户生效</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 有hard和soft两个限制，- 表示同时设置</span>
</span></span></code></pre></div><p>conf文件修改完成后，启动新的shell会话（重新ssh上去），这些limit对新的shell会话就生效了，不需要重启机器哦（需要重新登陆shell）</p>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/responsive-embedded-iframe-hugo-youtueb-vedio/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">响应式iframe 16:9—hugo博客嵌入youtube视频</span>
    </a>
    
    
    <a href="/posts/use-sync-pool-go/" class="navigation-next">
      <span class="navigation-tittle">go使用sync.pool实现复用[]byte——降低IO密集应用的GC频率</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


        </div>
        
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    




    



    </body>
</html>
