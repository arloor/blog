<!DOCTYPE html>
<html lang="zh-CN">

    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/mtu/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.157.0">

    
    
    

<title>MTU详解 • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="MTU详解">
  <meta name="twitter:description" content="MTU (Maximum Transmission Unit) 是网络通信中的一个关键参数。本文将通过实际案例，深入探讨 MTU 的工作机制、Path MTU Discovery (PMTUD) 协议，以及在 PPPoE 家庭网络环境下的实际应用。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/mtu/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="MTU详解">
  <meta property="og:description" content="MTU (Maximum Transmission Unit) 是网络通信中的一个关键参数。本文将通过实际案例，深入探讨 MTU 的工作机制、Path MTU Discovery (PMTUD) 协议，以及在 PPPoE 家庭网络环境下的实际应用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-22T13:05:02+08:00">
    <meta property="article:modified_time" content="2025-10-22T13:05:02+08:00">
    <meta property="article:tag" content="Undefined">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.debf1b963c1830f6b9b96ee48c2b4a22c31c7c3885a87bed290c0e198fc6a08d.css" integrity="sha256-3r8bljwYMPa5uW7kjCtKIsMcfDiFqHvtKQwOGY/GoI0=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.6b7222b4ddd3cebd47d144a2e37ade6cbbb64f47e31d8feac655896156ade206.css" integrity="sha256-a3IitN3Tzr1H0USi43rebLu2T0fjHY/qxlWJYVat4gY=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>



<body class="  ">
  
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content menu-content--mobile">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana-iframe">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/net-iframe">
						<span>网速监控</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/nat">
						<span>NAT规则</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/stock">
						<span>股票监控</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me" target="_blank"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me" target="_blank"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me" target="_blank"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me" target="_blank"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    <div class="menu-content menu-content--desktop">
      <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana-iframe">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/net-iframe">
						<span>网速监控</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/nat">
						<span>NAT规则</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/stock">
						<span>股票监控</span>
					</a>
				</li>
			 
		
	</ul>
</div>

    </div>
    <div class="social-wrap social-wrap--desktop">
      <section class="social">
	
	<a href="https://x.com/njulgh" rel="me" target="_blank"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me" target="_blank"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me" target="_blank"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me" target="_blank"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
    </div>
    
<div class="copyright">
  &copy; 2026 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>

  <div class="content container">
    
    
<article>
  <header>
    <h1>MTU详解</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Oct 22, 2025
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/undefined">UNDEFINED</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/undefined">undefined</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 13 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#一mtu-基础概念">一、MTU 基础概念</a>
      <ul>
        <li><a href="#11-什么是-mtu">1.1 什么是 MTU</a></li>
        <li><a href="#12-mtu-的实际含义">1.2 MTU 的实际含义</a></li>
        <li><a href="#13-如何查看和测试-mtu">1.3 如何查看和测试 MTU</a></li>
      </ul>
    </li>
    <li><a href="#二mtu-在网络协议栈中的位置">二、MTU 在网络协议栈中的位置</a>
      <ul>
        <li><a href="#21-mtu-不在协议包头中传递">2.1 MTU 不在协议包头中传递</a></li>
        <li><a href="#22-mtu-的工作流程">2.2 MTU 的工作流程</a></li>
      </ul>
    </li>
    <li><a href="#三tcp-的-mss-协商机制">三、TCP 的 MSS 协商机制</a>
      <ul>
        <li><a href="#31-mss-在-tcp-握手中的传递">3.1 MSS 在 TCP 握手中的传递</a></li>
        <li><a href="#32-为什么-ack-不携带-mss">3.2 为什么 ACK 不携带 MSS</a></li>
        <li><a href="#33-tcp-options-在不同包中的使用">3.3 TCP Options 在不同包中的使用</a></li>
      </ul>
    </li>
    <li><a href="#四pppoe-环境下的-mtu-问题">四、PPPoE 环境下的 MTU 问题</a>
      <ul>
        <li><a href="#41-问题场景">4.1 问题场景</a></li>
        <li><a href="#42-两种处理情况">4.2 两种处理情况</a></li>
        <li><a href="#43-tcp-连接的自动适应">4.3 TCP 连接的自动适应</a></li>
        <li><a href="#44-udp-和-icmp-的潜在问题">4.4 UDP 和 ICMP 的潜在问题</a></li>
        <li><a href="#45-解决方案">4.5 解决方案</a></li>
        <li><a href="#46-测试和验证">4.6 测试和验证</a></li>
      </ul>
    </li>
    <li><a href="#五path-mtu-discovery-pmtud-深度解析">五、Path MTU Discovery (PMTUD) 深度解析</a>
      <ul>
        <li><a href="#51-pmtud-是跨层协作机制">5.1 PMTUD 是跨层协作机制</a></li>
        <li><a href="#52-pmtud-的完整工作流程">5.2 PMTUD 的完整工作流程</a></li>
        <li><a href="#53-tcp-如何感知-icmp">5.3 TCP 如何感知 ICMP</a></li>
        <li><a href="#54-实际抓包验证">5.4 实际抓包验证</a></li>
        <li><a href="#55-mss-协商的局限性">5.5 MSS 协商的局限性</a></li>
        <li><a href="#56-现代改进plpmtud">5.6 现代改进：PLPMTUD</a></li>
        <li><a href="#57-pppoe-场景下的-pmtud-实际效果">5.7 PPPoE 场景下的 PMTUD 实际效果</a></li>
        <li><a href="#58-pmtud-对不同协议的作用">5.8 PMTUD 对不同协议的作用</a></li>
      </ul>
    </li>
    <li><a href="#六udp-协议与-mtu">六、UDP 协议与 MTU</a>
      <ul>
        <li><a href="#61-udp-的-df-标志不是固定的">6.1 UDP 的 DF 标志不是固定的</a></li>
        <li><a href="#62-pppoe-场景中的-udp-行为">6.2 PPPoE 场景中的 UDP 行为</a></li>
        <li><a href="#63-udp-与-tcp-在-pmtud-上的关键区别">6.3 UDP 与 TCP 在 PMTUD 上的关键区别</a></li>
        <li><a href="#64-udp-应用如何处理-pmtud">6.4 UDP 应用如何处理 PMTUD</a></li>
        <li><a href="#65-常见误区">6.5 常见误区</a></li>
        <li><a href="#66-实际建议">6.6 实际建议</a></li>
      </ul>
    </li>
    <li><a href="#七总结与最佳实践">七、总结与最佳实践</a>
      <ul>
        <li><a href="#71-核心要点">7.1 核心要点</a></li>
        <li><a href="#72-pppoe-环境最佳实践">7.2 PPPoE 环境最佳实践</a></li>
        <li><a href="#73-诊断和验证">7.3 诊断和验证</a></li>
        <li><a href="#74-性能影响量化">7.4 性能影响量化</a></li>
        <li><a href="#75-参考资源">7.5 参考资源</a></li>
      </ul>
    </li>
    <li><a href="#附录常用命令速查">附录：常用命令速查</a>
      <ul>
        <li><a href="#windows">Windows</a></li>
        <li><a href="#linux">Linux</a></li>
        <li><a href="#macos">macOS</a></li>
      </ul>
    </li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>MTU (Maximum Transmission Unit) 是网络通信中的一个关键参数。本文将通过实际案例，深入探讨 MTU 的工作机制、Path MTU Discovery (PMTUD) 协议，以及在 PPPoE 家庭网络环境下的实际应用。</p>
<h2 id="一mtu-基础概念">一、MTU 基础概念</h2>
<h3 id="11-什么是-mtu">1.1 什么是 MTU</h3>
<p>MTU（Maximum Transmission Unit，最大传输单元）是<strong>网络接口的配置参数</strong>，定义了数据链路层（第 2 层）能够传输的最大数据包大小。需要注意的是，MTU <strong>本身不在任何协议的包头中传递</strong>，这是一个常见的误解。</p>
<p><strong>常见的 MTU 值：</strong></p>
<ul>
<li>标准以太网：1500 字节</li>
<li>PPPoE 连接：1492 字节（需要额外 8 字节 PPPoE 头部）</li>
<li>Jumbo Frame：9000 字节</li>
</ul>
<h3 id="12-mtu-的实际含义">1.2 MTU 的实际含义</h3>
<p>我们通常说的 MTU 是<strong>指 IP 层的最大传输单元，不包括数据链路层的开销</strong>。例如：</p>
<ul>
<li>IP 层 MTU：1500 字节</li>
<li>加上以太网帧头部：14 字节</li>
<li>加上帧校验序列（FCS）：4 字节</li>
<li><strong>完整的以太网帧</strong>：1518 字节</li>
</ul>
<h3 id="13-如何查看和测试-mtu">1.3 如何查看和测试 MTU</h3>
<p><strong>Windows 系统查看 MTU：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># 方法 1：查看网络接口 MTU</span>
</span></span><span style="display:flex;"><span>netsh interface ipv4 show subinterfaces
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 方法 2：使用 PowerShell</span>
</span></span><span style="display:flex;"><span>Get-NetIPInterface | Select-Object InterfaceAlias, InterfaceIndex, NlMtu
</span></span></code></pre></div><p><strong>使用 Ping 测试实际 MTU：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># 测试最大不分片包大小</span>
</span></span><span style="display:flex;"><span>ping <span style="color:#f92672">-f</span> -l <span style="color:#ae81ff">1464</span> www.baidu.com
</span></span></code></pre></div><p>参数说明：</p>
<ul>
<li><code>-f</code>：设置 DF (Don&rsquo;t Fragment) 标志，不允许分片</li>
<li><code>-l 1464</code>：指定数据包大小</li>
</ul>
<p><strong>包大小计算：</strong></p>
<ul>
<li>ICMP 数据：1464 字节</li>
<li>IP 头部：20 字节</li>
<li>ICMP 头部：8 字节</li>
<li><strong>总 MTU</strong>：1492 字节</li>
</ul>
<p>这就是为什么家庭 PPPoE 宽带的实际 MTU 是 1492 字节，而不是网卡配置的 1500 字节。</p>
<h2 id="二mtu-在网络协议栈中的位置">二、MTU 在网络协议栈中的位置</h2>
<h3 id="21-mtu-不在协议包头中传递">2.1 MTU 不在协议包头中传递</h3>
<p>MTU 本身不作为字段存在于任何协议的包头中，但以下字段与 MTU 机制相关：</p>
<h4 id="ip-层相关字段">IP 层相关字段</h4>
<p><strong>IPv4：</strong></p>
<ul>
<li><strong>Total Length 字段</strong>（16 位）：指示整个 IP 数据包的长度</li>
<li><strong>Don&rsquo;t Fragment (DF) 标志位</strong>：当设置时，路由器不能分片该数据包</li>
<li><strong>Fragment Offset 字段</strong>：用于 IP 分片重组</li>
</ul>
<p><strong>IPv6：</strong></p>
<ul>
<li><strong>Payload Length 字段</strong>（16 位）：指示 IPv6 载荷长度</li>
<li><strong>注意</strong>：IPv6 不支持路由器分片，必须在源端处理</li>
</ul>
<h4 id="icmp-协议">ICMP 协议</h4>
<p><strong>Path MTU Discovery 通过 ICMP 消息实现：</strong></p>
<p>当路由器因数据包超过 MTU 且设置了 DF 标志而丢弃数据包时：</p>
<ol>
<li>路由器发送 <strong>ICMP Type 3 Code 4</strong>（目标不可达 - 需要分片但设置了 DF）消息</li>
<li>该 ICMP 消息的 <strong>Next-Hop MTU 字段</strong>（16 位）携带链路的 MTU 值</li>
</ol>
<p>这是 <strong>Path MTU Discovery</strong> 机制的核心部分。</p>
<h4 id="tcp-层">TCP 层</h4>
<p><strong>MSS (Maximum Segment Size) 选项：</strong></p>
<ul>
<li>在 TCP 三次握手的 SYN 包中传递</li>
<li>出现在 TCP Options 字段中</li>
<li>格式：Kind=2，Length=4，后跟 16 位 MSS 值</li>
<li>计算公式：<strong>MSS = MTU - IP 头部 (20) - TCP 头部 (20)</strong></li>
<li>典型值：1460 字节（基于 1500 字节 MTU）</li>
</ul>
<h3 id="22-mtu-的工作流程">2.2 MTU 的工作流程</h3>
<pre tabindex="0"><code>发送端：
1. 查询本地接口 MTU（如 1500 字节）
2. 计算 TCP MSS = 1500 - 20(IP) - 20(TCP) = 1460
3. 在 SYN 包的 TCP 选项中发送 MSS=1460

中间路由器：
1. 接收到大于链路 MTU 的数据包
2. 若 DF=1，丢弃并发送 ICMP（包含该链路的 MTU）
3. 若 DF=0，进行 IP 分片转发

接收端：
1. 从对方 SYN 包中读取 MSS
2. 使用 min(本地 MSS, 对端 MSS) 作为发送大小
</code></pre><h2 id="三tcp-的-mss-协商机制">三、TCP 的 MSS 协商机制</h2>
<h3 id="31-mss-在-tcp-握手中的传递">3.1 MSS 在 TCP 握手中的传递</h3>
<p>MSS 选项<strong>只在 SYN 包中传递</strong>，不在纯 ACK 包中携带。</p>
<p><strong>TCP 三次握手示意：</strong></p>
<pre tabindex="0"><code>客户端                                服务器
   |                                    |
   |------ SYN (MSS=1460) -----------&gt;|
   |                                    |
   |&lt;----- SYN-ACK (MSS=1460) --------|
   |                                    |
   |------ ACK (无 MSS) -------------&gt;|
   |                                    |
</code></pre><p><strong>详细说明：</strong></p>
<ol>
<li>
<p><strong>第一次握手（SYN）</strong></p>
<ul>
<li>客户端发送 SYN 包</li>
<li>TCP Options 中包含 MSS 选项</li>
<li>告知服务器：&ldquo;我能接收的最大段大小是 1460 字节&rdquo;</li>
</ul>
</li>
<li>
<p><strong>第二次握手（SYN-ACK）</strong></p>
<ul>
<li>服务器回复 SYN-ACK 包</li>
<li><strong>SYN 标志位仍然为 1</strong>，所以可以携带 MSS 选项</li>
<li>告知客户端服务器的 MSS 值</li>
</ul>
</li>
<li>
<p><strong>第三次握手（纯 ACK）</strong></p>
<ul>
<li>客户端发送 ACK 包</li>
<li><strong>SYN 标志位为 0</strong></li>
<li><strong>不携带 MSS 选项</strong></li>
<li>MSS 协商已完成</li>
</ul>
</li>
</ol>
<h3 id="32-为什么-ack-不携带-mss">3.2 为什么 ACK 不携带 MSS</h3>
<p><strong>协议规定：</strong>
根据 RFC 793 和 RFC 879：</p>
<ul>
<li>MSS 选项<strong>仅在 SYN 包中有效</strong>（SYN=1）</li>
<li>普通 ACK 包（SYN=0）中的 MSS 选项会被忽略</li>
</ul>
<p><strong>技术原因：</strong></p>
<ol>
<li><strong>单向声明</strong>：MSS 是发送方告知对方&quot;你发给我的数据最大能有多大&quot;</li>
<li><strong>握手期间协商</strong>：双方在建立连接时各自声明一次即可</li>
<li><strong>连接期间固定</strong>：MSS 在连接建立后不会改变</li>
</ol>
<h3 id="33-tcp-options-在不同包中的使用">3.3 TCP Options 在不同包中的使用</h3>
<table>
  <thead>
      <tr>
          <th>TCP 选项</th>
          <th>SYN</th>
          <th>SYN-ACK</th>
          <th>ACK</th>
          <th>数据包</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>MSS (Kind=2)</td>
          <td>✓</td>
          <td>✓</td>
          <td>✗</td>
          <td>✗</td>
      </tr>
      <tr>
          <td>Window Scale (Kind=3)</td>
          <td>✓</td>
          <td>✓</td>
          <td>✗</td>
          <td>✗</td>
      </tr>
      <tr>
          <td>SACK Permitted (Kind=4)</td>
          <td>✓</td>
          <td>✓</td>
          <td>✗</td>
          <td>✗</td>
      </tr>
      <tr>
          <td>SACK (Kind=5)</td>
          <td>✗</td>
          <td>✗</td>
          <td>✓</td>
          <td>✓</td>
      </tr>
      <tr>
          <td>Timestamp (Kind=8)</td>
          <td>✓</td>
          <td>✓</td>
          <td>✓</td>
          <td>✓</td>
      </tr>
  </tbody>
</table>
<h2 id="四pppoe-环境下的-mtu-问题">四、PPPoE 环境下的 MTU 问题</h2>
<h3 id="41-问题场景">4.1 问题场景</h3>
<p>典型的家庭网络拓扑：</p>
<pre tabindex="0"><code>内网设备(MTU=1500) --&gt; 路由器 LAN 口(MTU=1500)
                   --&gt; 路由器 WAN 口(MTU=1492) --&gt; ISP
</code></pre><p><strong>问题：</strong> 当内网设备发送 1500 字节的 IP 包时，到达路由器 WAN 口（PPPoE MTU=1492）会发生什么？</p>
<h3 id="42-两种处理情况">4.2 两种处理情况</h3>
<h4 id="情况-1df-标志未设置df0">情况 1：DF 标志未设置（DF=0）</h4>
<p>路由器会进行 <strong>IP 分片</strong>：</p>
<ul>
<li>第一个分片：1492 字节（包含原始 IP 头）</li>
<li>第二个分片：8 字节剩余数据 + 20 字节新 IP 头 = 28 字节</li>
<li><strong>性能影响</strong>：增加路由器 CPU 负担，降低吞吐量 10-30%</li>
</ul>
<h4 id="情况-2df-标志已设置df1">情况 2：DF 标志已设置（DF=1）</h4>
<p>这是现代 TCP 连接的常见情况：</p>
<ol>
<li>路由器<strong>丢弃数据包</strong></li>
<li>发送 <strong>ICMP Type 3 Code 4</strong> 消息回内网设备</li>
<li>ICMP 消息告知：&ldquo;需要分片但设置了 DF，下一跳 MTU=1492&rdquo;</li>
<li>内网设备收到后，降低发送包大小至 1492 或更小</li>
<li>这就是 <strong>Path MTU Discovery (PMTUD)</strong> 机制</li>
</ol>
<h3 id="43-tcp-连接的自动适应">4.3 TCP 连接的自动适应</h3>
<p><strong>通常不会有严重问题</strong>，因为存在以下机制：</p>
<h4 id="1-mss-协商自动调整">1. MSS 协商自动调整</h4>
<pre tabindex="0"><code>内网设备计算 MSS：
- 如果路由器正确配置 MSS Clamping
- TCP SYN 包的 MSS 会被路由器改写
- MSS = 1492(PPPoE MTU) - 20(IP 头) - 20(TCP 头) = 1452
</code></pre><h4 id="2-pmtud-发现">2. PMTUD 发现</h4>
<ul>
<li>即使初始包过大，通过 ICMP 反馈快速调整</li>
<li>现代操作系统都支持 PMTUD</li>
</ul>
<h4 id="3-路由器-mss-clamping">3. 路由器 MSS Clamping</h4>
<ul>
<li>大多数路由器默认启用此功能</li>
<li>自动修改通过的 TCP SYN 包的 MSS 值</li>
</ul>
<h3 id="44-udp-和-icmp-的潜在问题">4.4 UDP 和 ICMP 的潜在问题</h3>
<p>这些协议<strong>没有 MSS 协商机制</strong>：</p>
<ul>
<li>应用层直接发送大包可能超过 PPPoE MTU</li>
<li>如果 DF=0：被路由器分片，性能下降</li>
<li>如果 DF=1：被丢弃，应用层需要处理</li>
</ul>
<h3 id="45-解决方案">4.5 解决方案</h3>
<h4 id="方案-1修改内网设备-mtu最彻底">方案 1：修改内网设备 MTU（最彻底）</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Linux</span>
</span></span><span style="display:flex;"><span>ip link set eth0 mtu <span style="color:#ae81ff">1492</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Windows</span>
</span></span><span style="display:flex;"><span>netsh interface ipv4 set subinterface <span style="color:#e6db74">&#34;以太网&#34;</span> mtu<span style="color:#f92672">=</span><span style="color:#ae81ff">1492</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># macOS</span>
</span></span><span style="display:flex;"><span>sudo ifconfig en0 mtu <span style="color:#ae81ff">1492</span>
</span></span></code></pre></div><p><strong>优点</strong>：彻底避免分片
<strong>缺点</strong>：需要配置每台设备</p>
<h4 id="方案-2路由器启用-mss-clamping推荐">方案 2：路由器启用 MSS Clamping（推荐）</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 使用 iptables</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  -j TCPMSS --clamp-mss-to-pmtu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 或直接指定 MSS 值</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  -j TCPMSS --set-mss <span style="color:#ae81ff">1452</span>
</span></span></code></pre></div><p><strong>优点</strong>：对内网设备透明，自动处理 TCP 连接
<strong>缺点</strong>：只对 TCP 有效，UDP 仍可能有问题</p>
<h4 id="方案-3启用-pmtud-并确保-icmp-畅通">方案 3：启用 PMTUD 并确保 ICMP 畅通</h4>
<p>确保：</p>
<ul>
<li>路由器不阻止 ICMP Type 3 Code 4 消息</li>
<li>内网设备防火墙允许 ICMP</li>
<li>内网设备操作系统启用 PMTUD（一般默认启用）</li>
</ul>
<h3 id="46-测试和验证">4.6 测试和验证</h3>
<h4 id="测试是否存在分片问题">测试是否存在分片问题</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Linux/macOS</span>
</span></span><span style="display:flex;"><span>ping -M <span style="color:#66d9ef">do</span> -s <span style="color:#ae81ff">1464</span> 8.8.8.8  <span style="color:#75715e"># 1464+20(IP)+8(ICMP)=1492，应该成功</span>
</span></span><span style="display:flex;"><span>ping -M <span style="color:#66d9ef">do</span> -s <span style="color:#ae81ff">1472</span> 8.8.8.8  <span style="color:#75715e"># 1472+20+8=1500，可能失败</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Windows</span>
</span></span><span style="display:flex;"><span>ping -f -l <span style="color:#ae81ff">1464</span> 8.8.8.8
</span></span><span style="display:flex;"><span>ping -f -l <span style="color:#ae81ff">1472</span> 8.8.8.8
</span></span></code></pre></div><h4 id="查看路由缓存中的-pmtu">查看路由缓存中的 PMTU</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Linux</span>
</span></span><span style="display:flex;"><span>ip route get 8.8.8.8
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 输出示例：</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 8.8.8.8 via 192.168.1.1 dev eth0 src 192.168.1.100</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     cache expires 597sec mtu 1492</span>
</span></span></code></pre></div><h4 id="检查-mss-clamping-是否生效">检查 MSS Clamping 是否生效</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 在内网设备抓包查看 SYN 包的 MSS</span>
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;tcp[tcpflags] &amp; tcp-syn != 0&#39;</span> -vv
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看 MSS 值是否被改写为 1452</span>
</span></span></code></pre></div><h2 id="五path-mtu-discovery-pmtud-深度解析">五、Path MTU Discovery (PMTUD) 深度解析</h2>
<h3 id="51-pmtud-是跨层协作机制">5.1 PMTUD 是跨层协作机制</h3>
<p>PMTUD 确实是通过 ICMP 实现的，但它<strong>完全可以作用到 TCP</strong>。这是一个<strong>跨层协作机制</strong>：</p>
<pre tabindex="0"><code>应用层 (HTTP/FTP 等)
    ↓
传输层 (TCP) ← 接收 PMTUD 结果，调整发送大小
    ↓
网络层 (IP) ← 设置 DF 标志，处理 ICMP 反馈
    ↓
ICMP ← 传递 MTU 信息
</code></pre><h3 id="52-pmtud-的完整工作流程">5.2 PMTUD 的完整工作流程</h3>
<h4 id="步骤-1tcp-发送数据包">步骤 1：TCP 发送数据包</h4>
<pre tabindex="0"><code>内网设备 TCP 层：
1. 根据本地 MSS (1460) 构造 TCP 段
2. 交给 IP 层封装
3. IP 层添加 20 字节头部，总共 1480 字节
4. IP 层设置 DF=1 标志（Don&#39;t Fragment）
</code></pre><h4 id="步骤-2路由器发现-mtu-不足">步骤 2：路由器发现 MTU 不足</h4>
<pre tabindex="0"><code>路由器 WAN 口 (MTU=1492)：
1. 收到 1500 字节的 IP 包
2. 检查：包大小(1500) &gt; MTU(1492) 且 DF=1
3. 无法分片，丢弃数据包
4. 生成 ICMP 消息返回
</code></pre><h4 id="步骤-3icmp-消息内容">步骤 3：ICMP 消息内容</h4>
<pre tabindex="0"><code>ICMP 包结构：
- Type: 3 (Destination Unreachable)
- Code: 4 (Fragmentation Needed and DF Set)
- Next-Hop MTU: 1492 (关键信息)
- 原始 IP 包的头部 + 前 8 字节数据（用于识别连接）
</code></pre><h4 id="步骤-4tcp-层接收并处理">步骤 4：TCP 层接收并处理</h4>
<pre tabindex="0"><code>内网设备收到 ICMP：
1. 操作系统内核的 IP 层处理 ICMP 消息
2. 提取 Next-Hop MTU = 1492
3. 更新路由缓存中该目的地的 PMTU 值
4. 通知 TCP 层：到该目的地的路径 MTU 是 1492
5. TCP 层调整发送窗口，后续 TCP 段不超过：
   1492 - 20(IP 头) - 20(TCP 头) = 1452 字节
</code></pre><h3 id="53-tcp-如何感知-icmp">5.3 TCP 如何感知 ICMP</h3>
<p><strong>内核层面的关联机制：</strong></p>
<p>ICMP 消息携带<strong>原始 IP 包的前 28 字节</strong>：</p>
<ul>
<li>20 字节 IP 头（包含源/目的 IP）</li>
<li>8 字节 TCP 头（包含源/目的端口）</li>
</ul>
<p>操作系统通过这些信息找到对应的 TCP 连接（<strong>四元组匹配</strong>：源 IP、源端口、目的 IP、目的端口）。</p>
<p><strong>内核简化逻辑（伪代码）：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">icmp_unreach</span>(<span style="color:#66d9ef">struct</span> icmp_hdr <span style="color:#f92672">*</span>icmp) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (icmp<span style="color:#f92672">-&gt;</span>code <span style="color:#f92672">==</span> ICMP_FRAG_NEEDED) {
</span></span><span style="display:flex;"><span>        u32 new_mtu <span style="color:#f92672">=</span> icmp<span style="color:#f92672">-&gt;</span>un.frag.mtu;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从 ICMP 载荷中提取原始 IP 头
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>orig_ip <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>)icmp<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 找到对应的 TCP 连接
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_socket</span>(orig_ip);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新该连接的 PMTU
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sk <span style="color:#f92672">&amp;&amp;</span> sk<span style="color:#f92672">-&gt;</span>sk_protocol <span style="color:#f92672">==</span> IPPROTO_TCP) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tcp_update_mtu</span>(sk, new_mtu);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="54-实际抓包验证">5.4 实际抓包验证</h3>
<p><strong>典型抓包输出：</strong></p>
<pre tabindex="0"><code>1. 12:00:00.100 IP 192.168.1.100.45678 &gt; 93.184.216.34.443:
   Flags [.], seq 1:1461, ack 1, win 65535, length 1460
   # TCP 发送 1460 字节数据段

2. 12:00:00.105 IP 路由器WAN_IP &gt; 192.168.1.100:
   ICMP 93.184.216.34 unreachable - need to frag (mtu 1492)
   # 路由器返回 ICMP

3. 12:00:00.106 IP 192.168.1.100.45678 &gt; 93.184.216.34.443:
   Flags [.], seq 1:1453, ack 1, win 65535, length 1452
   # TCP 重传，大小已调整为 1452
</code></pre><h3 id="55-mss-协商的局限性">5.5 MSS 协商的局限性</h3>
<p>MSS 只解决<strong>端到端的声明</strong>，无法发现<strong>路径中间的瓶颈</strong>。由于TCP通常设置ip不分片，中间路径有瓶颈时，通常数据会被丢弃。</p>
<pre tabindex="0"><code>客户端 服务器
| |
|-------- SYN (MSS=1460) ---------------&gt;|
| |
|&lt;------- SYN-ACK (MSS=1460) ------------|
| |
|-------- ACK --------------------------&gt;|

协商结果: 双方都知道对方能接收的最大段大小
</code></pre><p><strong>MSS 只反映</strong>:</p>
<ul>
<li>客户端本地接口的 MTU</li>
<li>服务器本地接口的 MTU</li>
<li><strong>仅仅是两端的声明</strong>：&ldquo;我的接口能接收这么大的包&rdquo;（我的门有这么大）</li>
</ul>
<h4 id="问题场景">问题场景</h4>
<pre tabindex="0"><code>
客户端 (MTU 1500) → 路由器 A (MTU 1500) → 路由器 B (MTU 1400) → 服务器 (MTU 1500)
                                             ↑
                                             路径瓶颈！
</code></pre><p><strong>TCP 握手时</strong>:</p>
<pre tabindex="0"><code>
客户端: &#34;我的 MSS = 1460&#34; (基于本地 MTU 1500)
服务器: &#34;我的 MSS = 1460&#34; (基于本地 MTU 1500)
双方协商: 使用 MSS = 1460
</code></pre><p><strong>实际发送数据时</strong>:</p>
<pre tabindex="0"><code>
客户端发送: 1460 (数据) + 20 (TCP 头) + 20 (IP 头) = 1500 字节包
↓
路由器 A: 转发 (MTU 1500, OK)
↓
路由器 B: MTU 只有 1400！ - 如果 DF=1: 丢弃 + 返回 ICMP &#34;需要分片&#34; - 如果 DF=0: 分片 (IPv4)
</code></pre><h4 id="为什么-mss-无法发现中间瓶颈">为什么 MSS 无法发现中间瓶颈？</h4>
<p><strong>核心原因</strong>: MSS 是 <strong>声明式的</strong>，不是 <strong>探测式的</strong></p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>MSS</th>
          <th>Path MTU Discovery</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>时机</td>
          <td>TCP 握手时协商</td>
          <td>数据传输时动态发现</td>
      </tr>
      <tr>
          <td>信息来源</td>
          <td>两端主机声明</td>
          <td>路径中所有路由器反馈</td>
      </tr>
      <tr>
          <td>是否探测路径</td>
          <td>❌ 否</td>
          <td>✅ 是</td>
      </tr>
      <tr>
          <td>能否发现中间瓶颈</td>
          <td>❌ 不能</td>
          <td>✅ 能</td>
      </tr>
  </tbody>
</table>
<h4 id="实际案例">实际案例</h4>
<p><strong>场景 1: VPN 隧道</strong></p>
<pre tabindex="0"><code>
你的电脑 (MSS=1460, MTU=1500)
↓
本地路由器 (MTU=1500)
↓
VPN 网关 (MTU=1400, 因为 VPN 封装开销)
↓
远程服务器 (MSS=1460, MTU=1500)
</code></pre><p><strong>问题</strong>:</p>
<pre tabindex="0"><code>
1. TCP 握手: MSS 协商为 1460 ✓
2. 发送数据: 1500 字节包到达 VPN 网关
3. VPN 网关: &#34;这个包太大了！&#34;
   - 需要加 VPN 头部，总共会超过 1500
   - 丢弃包 + 返回 ICMP
4. 你的电脑: 收到 ICMP，降低 Path MTU 到 1400
5. 重新发送: 使用更小的包 (1360 数据 + 40 头部 = 1400)
</code></pre><p><strong>MSS 看不到这个问题</strong>: 因为 VPN 网关不参与 TCP 握手！</p>
<h4 id="path-mtu-discovery-如何解决">Path MTU Discovery 如何解决</h4>
<pre tabindex="0"><code>
初始状态:
客户端认为 Path MTU = 1500 (基于本地接口)

发送阶段:
[1500 字节包, DF=1] → 路由器 B (MTU 1400)
↓
丢弃 + ICMP Type 3 Code 4
&#34;MTU = 1400&#34;
↓
客户端更新: Path MTU = 1400
MSS 调整为 = 1400 - 40 = 1360

后续传输:
[1400 字节包] → 路由器 B → 成功通过！ ✓
</code></pre><h4 id="完整的流程对比">完整的流程对比</h4>
<p><strong>仅使用 MSS</strong>:</p>
<pre tabindex="0"><code>
1. 握手: MSS = min(本地 MTU, 对端 MTU) - 40
2. 发送: 按 MSS 发送
3. 遇到瓶颈:
   - DF=1: 黑洞 (ICMP 被屏蔽时)
   - DF=0: 分片 (性能差)
</code></pre><p><strong>MSS + Path MTU Discovery</strong>:</p>
<pre tabindex="0"><code>
1. 握手: MSS = min(本地 MTU, 对端 MTU) - 40
2. 发送: 按 MSS 发送, DF=1
3. 遇到瓶颈:
   - 收到 ICMP
   - 动态调整 Path MTU
   - 自动降低 MSS
4. 后续: 使用优化的 MSS，避免分片和丢包
</code></pre><h4 id="现实中的例子">现实中的例子</h4>
<p><strong>场景</strong>: 你访问公司内网</p>
<pre tabindex="0"><code>
家里 (光猫 PPPoE, MTU=1492)
↓
ISP 骨干网 (MTU=1500)
↓
公司边界路由器 (MTU=1500)
↓
公司内部 (某个老交换机 MTU=1400)
↓
内网服务器 (MTU=1500)
</code></pre><p><strong>TCP 握手时</strong>:</p>
<ul>
<li>你: MSS = 1460 (基于家里 1500)</li>
<li>服务器: MSS = 1460</li>
<li>协商: MSS = 1460</li>
</ul>
<p><strong>实际数据传输</strong>:</p>
<ul>
<li>第一个包: 1500 字节 (1460+40)</li>
<li>到达公司内部交换机: <strong>失败！MTU 1400</strong></li>
<li>ICMP 返回: &ldquo;Path MTU = 1400&rdquo;</li>
<li>你的系统: 调整实际使用的 MSS = 1360</li>
</ul>
<h4 id="关键要点">关键要点</h4>
<ol>
<li>
<p><strong>MSS 是声明，不是探测</strong></p>
<ul>
<li>只知道两端的情况</li>
<li>不知道中间路径</li>
</ul>
</li>
<li>
<p><strong>Path MTU Discovery 是探测</strong></p>
<ul>
<li>通过实际发包 + ICMP 反馈</li>
<li>发现整条路径的最小 MTU</li>
</ul>
</li>
<li>
<p><strong>两者配合使用</strong></p>
</li>
</ol>
<pre tabindex="0"><code>
MSS: 提供初始值
PMTUD: 动态优化
最终 MSS = min(协商 MSS, Path MTU - 40)
</code></pre><ol start="4">
<li><strong>为什么需要 DF 标志</strong>
<ul>
<li>DF=1: 强制 PMTUD，避免分片</li>
<li>DF=0: 允许分片，但性能差</li>
</ul>
</li>
</ol>
<h4 id="类比理解">类比理解</h4>
<pre tabindex="0"><code>
MSS 就像:
两个人在电话里说 &#34;我家门有多宽&#34;

Path MTU Discovery 就像:
实际搬家具时，发现中间某个楼梯太窄
然后换小一点的家具
</code></pre><h3 id="56-现代改进plpmtud">5.6 现代改进：PLPMTUD</h3>
<p>TCP 还支持 <strong>Packetization Layer PMTUD (RFC 4821)</strong>：</p>
<ul>
<li>不依赖 ICMP（某些网络会过滤 ICMP）</li>
<li>通过主动发送不同大小的包并观察 ACK 来探测 MTU</li>
<li>TCP 层直接实现，更可靠</li>
</ul>
<h3 id="57-pppoe-场景下的-pmtud-实际效果">5.7 PPPoE 场景下的 PMTUD 实际效果</h3>
<pre tabindex="0"><code>第一个 TCP 连接建立时：
1. SYN 包协商 MSS=1460（假设没有 MSS Clamping）
2. TCP 发送 1500 字节 IP 包
3. 路由器 WAN 口返回 ICMP (mtu=1492)
4. 内核更新路由缓存：到该目的地 PMTU=1492
5. 该 TCP 连接后续段大小 ≤ 1452 字节
6. 其他新连接也会使用缓存的 PMTU=1492

路由缓存：
- 存储时间：通常 10 分钟（可配置）
- 定期探测是否 MTU 变化
</code></pre><h3 id="58-pmtud-对不同协议的作用">5.8 PMTUD 对不同协议的作用</h3>
<table>
  <thead>
      <tr>
          <th>协议</th>
          <th>DF 标志</th>
          <th>PMTUD 是否有效</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TCP</td>
          <td>通常设置 DF=1</td>
          <td><strong>有效</strong></td>
          <td>内核自动处理</td>
      </tr>
      <tr>
          <td>UDP</td>
          <td>应用决定</td>
          <td>部分有效</td>
          <td>需应用层配合</td>
      </tr>
      <tr>
          <td>ICMP</td>
          <td>ping 可设置</td>
          <td>有效</td>
          <td>测试用</td>
      </tr>
      <tr>
          <td>QUIC/HTTP3</td>
          <td>在 UDP 上实现</td>
          <td>有效</td>
          <td>协议层实现 PMTUD</td>
      </tr>
  </tbody>
</table>
<h2 id="六udp-协议与-mtu">六、UDP 协议与 MTU</h2>
<h3 id="61-udp-的-df-标志不是固定的">6.1 UDP 的 DF 标志不是固定的</h3>
<p>UDP 协议的 IP 包 DF 标志<strong>取决于多个因素</strong>，不是固定为 1 或 0。</p>
<h4 id="因素-1操作系统默认行为">因素 1：操作系统默认行为</h4>
<pre tabindex="0"><code>Linux (较新版本):
- IPv4 UDP: 默认 DF=0（允许分片）
- IPv6 UDP: 不支持路由器分片，源端必须处理

Windows:
- 默认 DF=0
- 某些版本会根据数据包大小动态设置

macOS/BSD:
- 默认 DF=0
- 可通过 setsockopt 配置
</code></pre><h4 id="因素-2应用层控制">因素 2：应用层控制</h4>
<p>应用程序可以通过 socket 选项控制 DF 标志：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Linux
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> IP_PMTUDISC_DO;  <span style="color:#75715e">// 强制设置 DF=1
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">setsockopt</span>(sock, IPPROTO_IP, IP_MTU_DISCOVER, <span style="color:#f92672">&amp;</span>val, <span style="color:#66d9ef">sizeof</span>(val));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可选值
</span></span></span><span style="display:flex;"><span>IP_PMTUDISC_DONT  <span style="color:#75715e">// DF=0，允许分片
</span></span></span><span style="display:flex;"><span>IP_PMTUDISC_WANT  <span style="color:#75715e">// 尽量设置 DF=1，但不强制
</span></span></span><span style="display:flex;"><span>IP_PMTUDISC_DO    <span style="color:#75715e">// 强制 DF=1
</span></span></span><span style="display:flex;"><span>IP_PMTUDISC_PROBE <span style="color:#75715e">// 用于 MTU 探测
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Windows
</span></span></span><span style="display:flex;"><span>DWORD val <span style="color:#f92672">=</span> IP_PMTUDISC_DO;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">setsockopt</span>(sock, IPPROTO_IP, IP_DONTFRAGMENT, (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>val, <span style="color:#66d9ef">sizeof</span>(val));
</span></span></code></pre></div><h4 id="因素-3具体协议实现">因素 3：具体协议实现</h4>
<table>
  <thead>
      <tr>
          <th>协议/应用</th>
          <th>DF 标志</th>
          <th>原因</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>DNS 查询</strong></td>
          <td>DF=0</td>
          <td>允许分片，确保可达性</td>
      </tr>
      <tr>
          <td><strong>QUIC/HTTP3</strong></td>
          <td>DF=1</td>
          <td>自己实现 PMTUD，不依赖 IP 分片</td>
      </tr>
      <tr>
          <td><strong>VPN (OpenVPN/WireGuard)</strong></td>
          <td>DF=1</td>
          <td>避免双重分片，性能优化</td>
      </tr>
      <tr>
          <td><strong>RTP/实时音视频</strong></td>
          <td>DF=0 或 1</td>
          <td>取决于实现</td>
      </tr>
      <tr>
          <td><strong>DHCP</strong></td>
          <td>DF=0</td>
          <td>必须保证可达</td>
      </tr>
      <tr>
          <td><strong>NTP</strong></td>
          <td>DF=0</td>
          <td>通常使用小包，允许分片</td>
      </tr>
      <tr>
          <td><strong>游戏协议</strong></td>
          <td>多数 DF=0</td>
          <td>小包为主，避免 PMTUD 延迟</td>
      </tr>
  </tbody>
</table>
<h3 id="62-pppoe-场景中的-udp-行为">6.2 PPPoE 场景中的 UDP 行为</h3>
<pre tabindex="0"><code>场景 1：UDP 包 ≤ 1472 字节，DF=0
- 1472 + 20(IP 头) = 1492，正好通过
- 如果 1473-1500 字节，路由器会分片

场景 2：UDP 包 &gt; 1472 字节，DF=0
- 路由器进行 IP 分片
- 第一片：1472 字节数据 + 20 字节 IP 头 = 1492
- 第二片：剩余数据 + 20 字节新 IP 头
- 性能下降，可能导致丢包

场景 3：UDP 包 &gt; 1472 字节，DF=1
- 路由器丢弃包
- 发送 ICMP (Type 3 Code 4, MTU=1492)
- 但 UDP 应用层不会自动处理 ICMP
- 应用层需要自己实现重传和调整包大小
</code></pre><h3 id="63-udp-与-tcp-在-pmtud-上的关键区别">6.3 UDP 与 TCP 在 PMTUD 上的关键区别</h3>
<h4 id="tcp-有状态连接">TCP (有状态连接)</h4>
<pre tabindex="0"><code>内核维护连接状态：
- 收到 ICMP 后自动调整后续段大小
- 重传被丢弃的段
- 应用层无感知
</code></pre><h4 id="udp-无状态">UDP (无状态)</h4>
<pre tabindex="0"><code>内核只更新路由缓存：
- 收到 ICMP 后更新 PMTU
- 但不会通知应用层
- 不会重传丢失的包
- 应用层需要：
  1. 主动查询路径 MTU
  2. 自己处理包大小
  3. 自己实现重传
</code></pre><h3 id="64-udp-应用如何处理-pmtud">6.4 UDP 应用如何处理 PMTUD</h3>
<h4 id="方法-1查询路径-mtu需要-df1">方法 1：查询路径 MTU（需要 DF=1）</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_DGRAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 启用 PMTUD
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> IP_PMTUDISC_DO;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">setsockopt</span>(sock, IPPROTO_IP, IP_MTU_DISCOVER, <span style="color:#f92672">&amp;</span>val, <span style="color:#66d9ef">sizeof</span>(val));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 发送数据
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">sendto</span>(sock, data, len, <span style="color:#ae81ff">0</span>, ...);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果 sendto 返回 EMSGSIZE 错误，查询 MTU
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> mtu;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">socklen_t</span> mtu_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(mtu);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">getsockopt</span>(sock, IPPROTO_IP, IP_MTU, <span style="color:#f92672">&amp;</span>mtu, <span style="color:#f92672">&amp;</span>mtu_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 根据 mtu 调整包大小
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> udp_payload <span style="color:#f92672">=</span> mtu <span style="color:#f92672">-</span> <span style="color:#ae81ff">20</span>(IP) <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span>(UDP);
</span></span></code></pre></div><h4 id="方法-2保守策略避免分片">方法 2：保守策略（避免分片）</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 直接使用安全的包大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SAFE_UDP_PAYLOAD 1200  </span><span style="color:#75715e">// 适用于绝大多数网络
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 或使用最小 MTU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIN_MTU_PAYLOAD (576 - 20 - 8)  </span><span style="color:#75715e">// IPv4 最小 MTU
</span></span></span></code></pre></div><h4 id="方法-3quic-的做法推荐">方法 3：QUIC 的做法（推荐）</h4>
<pre tabindex="0"><code>QUIC 协议在 UDP 上实现了完整的 PMTUD：
1. 初始使用 1200 字节包（保守）
2. 主动发送 Padding 帧探测更大 MTU
3. 如果丢包或收到 ICMP，降低包大小
4. 定期重新探测，适应路径变化
</code></pre><h3 id="65-常见误区">6.5 常见误区</h3>
<h4 id="误区-1udp-的-df-总是-0所以不怕-mtu-问题">误区 1：&ldquo;UDP 的 DF 总是 0，所以不怕 MTU 问题&rdquo;</h4>
<ul>
<li><strong>错误</strong>：IP 分片会降低性能，增加丢包率</li>
<li>分片包任何一片丢失，整个包都要重传</li>
<li>某些防火墙会丢弃分片包</li>
</ul>
<h4 id="误区-2udp-不支持-pmtud">误区 2：&ldquo;UDP 不支持 PMTUD&rdquo;</h4>
<ul>
<li><strong>部分正确</strong>：内核会更新路由 PMTU</li>
<li>但需要应用层主动配合使用</li>
</ul>
<h4 id="误区-3设置-df1-就能自动适应-mtu">误区 3：&ldquo;设置 DF=1 就能自动适应 MTU&rdquo;</h4>
<ul>
<li><strong>错误</strong>：对 UDP 来说，只是让内核拒绝发送过大的包</li>
<li>应用层必须自己处理 EMSGSIZE 错误</li>
</ul>
<h3 id="66-实际建议">6.6 实际建议</h3>
<h4 id="对于-pppoe-环境">对于 PPPoE 环境</h4>
<p><strong>应用开发者：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 推荐做法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_UDP_PAYLOAD 1400  </span><span style="color:#75715e">// 留足够余量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 1400 + 8(UDP) + 20(IP) = 1428 &lt; 1492，安全
</span></span></span></code></pre></div><p><strong>网络管理员：</strong></p>
<ul>
<li>UDP 应用通常自己控制包大小</li>
<li>路由器会对 DF=0 的包进行分片</li>
<li>监控是否有大量 IP 分片（性能指标）</li>
</ul>
<p><strong>诊断命令：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 查看 IP 分片统计</span>
</span></span><span style="display:flex;"><span>netstat -s | grep -i frag
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Linux</span>
</span></span><span style="display:flex;"><span>cat /proc/net/snmp | grep Ip:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 监控分片包</span>
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;ip[6:2] &amp; 0x3fff != 0&#39;</span> -nn
</span></span></code></pre></div><h2 id="七总结与最佳实践">七、总结与最佳实践</h2>
<h3 id="71-核心要点">7.1 核心要点</h3>
<ol>
<li><strong>MTU 是配置参数</strong>，不在协议包头中传递</li>
<li><strong>MSS 在 TCP 选项中协商</strong>（只在 SYN 包中）</li>
<li><strong>Path MTU 通过 ICMP 消息动态发现</strong></li>
<li><strong>PMTUD 是跨层协作机制</strong>，可以作用到 TCP</li>
<li><strong>UDP 需要应用层主动处理 PMTUD</strong></li>
</ol>
<h3 id="72-pppoe-环境最佳实践">7.2 PPPoE 环境最佳实践</h3>
<h4 id="tcp-连接">TCP 连接</h4>
<ol>
<li><strong>启用路由器 MSS Clamping</strong>（推荐）</li>
<li>确保 ICMP 消息畅通（PMTUD 依赖）</li>
<li>如果需要，统一内网 MTU 为 1492</li>
</ol>
<h4 id="udp-应用">UDP 应用</h4>
<ol>
<li><strong>限制 UDP 载荷 ≤ 1400 字节</strong>（最安全）</li>
<li>应用层实现 PMTUD（如 QUIC）</li>
<li>监控 IP 分片统计，及时发现问题</li>
</ol>
<h3 id="73-诊断和验证">7.3 诊断和验证</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 测试实际 MTU</span>
</span></span><span style="display:flex;"><span>ping -f -l <span style="color:#ae81ff">1464</span> 8.8.8.8  <span style="color:#75715e"># Windows</span>
</span></span><span style="display:flex;"><span>ping -M <span style="color:#66d9ef">do</span> -s <span style="color:#ae81ff">1464</span> 8.8.8.8  <span style="color:#75715e"># Linux/macOS</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看路由缓存中的 PMTU</span>
</span></span><span style="display:flex;"><span>ip route get 8.8.8.8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 MSS Clamping</span>
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;tcp[tcpflags] &amp; tcp-syn != 0&#39;</span> -vv
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 监控 IP 分片</span>
</span></span><span style="display:flex;"><span>netstat -s | grep -i frag
</span></span></code></pre></div><h3 id="74-性能影响量化">7.4 性能影响量化</h3>
<p>假设每秒传输 100MB 数据：</p>
<table>
  <thead>
      <tr>
          <th>场景</th>
          <th>CPU 使用率增加</th>
          <th>吞吐量下降</th>
          <th>延迟增加</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>无分片</td>
          <td>0%</td>
          <td>0%</td>
          <td>0ms</td>
      </tr>
      <tr>
          <td>IP 分片</td>
          <td>20-40%</td>
          <td>10-30%</td>
          <td>5-20ms</td>
      </tr>
      <tr>
          <td>PMTUD 优化</td>
          <td>&lt;5%</td>
          <td>&lt;5%</td>
          <td>&lt;2ms</td>
      </tr>
  </tbody>
</table>
<h3 id="75-参考资源">7.5 参考资源</h3>
<ul>
<li><strong>RFC 793</strong>：TCP 协议</li>
<li><strong>RFC 879</strong>：TCP MSS 选项</li>
<li><strong>RFC 1191</strong>：Path MTU Discovery (IPv4)</li>
<li><strong>RFC 8201</strong>：Path MTU Discovery (IPv6)</li>
<li><strong>RFC 4821</strong>：Packetization Layer PMTUD</li>
</ul>
<hr>
<h2 id="附录常用命令速查">附录：常用命令速查</h2>
<h3 id="windows">Windows</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># 查看 MTU</span>
</span></span><span style="display:flex;"><span>netsh interface ipv4 show subinterfaces
</span></span><span style="display:flex;"><span>Get-NetIPInterface | Select-Object InterfaceAlias, InterfaceIndex, NlMtu
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置 MTU</span>
</span></span><span style="display:flex;"><span>netsh interface ipv4 set subinterface <span style="color:#e6db74">&#34;以太网&#34;</span> mtu=<span style="color:#ae81ff">1492</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 测试 MTU</span>
</span></span><span style="display:flex;"><span>ping <span style="color:#f92672">-f</span> -l <span style="color:#ae81ff">1464</span> www.baidu.com
</span></span></code></pre></div><h3 id="linux">Linux</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 查看 MTU</span>
</span></span><span style="display:flex;"><span>ip link show
</span></span><span style="display:flex;"><span>ip addr show
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置 MTU</span>
</span></span><span style="display:flex;"><span>ip link set eth0 mtu <span style="color:#ae81ff">1492</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 测试 MTU</span>
</span></span><span style="display:flex;"><span>ping -M <span style="color:#66d9ef">do</span> -s <span style="color:#ae81ff">1464</span> 8.8.8.8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看路由 PMTU</span>
</span></span><span style="display:flex;"><span>ip route get 8.8.8.8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看分片统计</span>
</span></span><span style="display:flex;"><span>cat /proc/net/snmp | grep Ip:
</span></span><span style="display:flex;"><span>netstat -s | grep -i frag
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 抓包分析</span>
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;tcp[tcpflags] &amp; tcp-syn != 0&#39;</span> -vv
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;icmp&#39;</span> -vv
</span></span><span style="display:flex;"><span>tcpdump -i eth0 <span style="color:#e6db74">&#39;ip[6:2] &amp; 0x3fff != 0&#39;</span> -nn  <span style="color:#75715e"># 分片包</span>
</span></span></code></pre></div><h3 id="macos">macOS</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 查看 MTU</span>
</span></span><span style="display:flex;"><span>ifconfig
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置 MTU</span>
</span></span><span style="display:flex;"><span>sudo ifconfig en0 mtu <span style="color:#ae81ff">1492</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 测试 MTU</span>
</span></span><span style="display:flex;"><span>ping -D -s <span style="color:#ae81ff">1464</span> 8.8.8.8
</span></span></code></pre></div><hr>
<p>本文通过理论与实践相结合的方式，深入探讨了 MTU 的工作原理和实际应用。希望能帮助读者更好地理解和解决网络通信中的 MTU 相关问题。</p>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/intel-ultra-265ks-bios/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Ultra 265k BIOS/风扇设置</span>
    </a>
    
    
    <a href="/posts/bbr-algorithm-analysis/" class="navigation-next">
      <span class="navigation-tittle">BBR 算法的流量控制与拥塞控制</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


  </div>
<style>
  .content.container {
        width: 100%;
        max-width: none;
        height: calc(100vh - var(--sidebar-height, 49px));
        border: none;
        display: block;
        overflow-y: auto;
        box-sizing: border-box;
        margin-left: 0;
        margin-right: 0;
  }

  body:not(.type-iframe) .content.container {
        padding-left: max(1.5rem, calc((100% - var(--content-max-width, 38rem)) / 2));
        padding-right: max(1.5rem, calc((100% - var(--content-max-width, 38rem)) / 2));
  }
</style>
<script>
    (function () {
        var contentSelector = '.content.container';
        var rafId = 0;
        var resizeDebounceTimer = 0;
        var pendingHashScroll = false;

        function getHashTarget() {
            var hash = window.location.hash;
            var targetId = '';

            if (!hash || hash === '#') {
                return null;
            }

            targetId = hash.slice(1);
            try {
                targetId = decodeURIComponent(targetId);
            } catch (e) {
                
            }

            return document.getElementById(targetId);
        }

        function scrollToHashTarget() {
            var target = getHashTarget();
            if (!target) {
                return;
            }
            try {
                target.scrollIntoView({ block: 'start', inline: 'nearest' });
            } catch (e) {
                target.scrollIntoView(true);
            }
        }

        function applyPendingHashScroll() {
            if (!pendingHashScroll) {
                return;
            }
            pendingHashScroll = false;
            scrollToHashTarget();
        }

        function resizeContentHeight() {
            var content = document.querySelector(contentSelector);
            if (!content) {
                return;
            }
            var rect = content.getBoundingClientRect();
            var available = window.innerHeight - rect.top;
            if (available < 0) {
                available = 0;
            }
            content.style.height = available + 'px';
            applyPendingHashScroll();
        }

        function scheduleResize() {
            if (rafId) {
                return;
            }
            rafId = window.requestAnimationFrame(function () {
                rafId = 0;
                resizeContentHeight();
            });
        }

        function scheduleResizeDebounced(delay) {
            window.clearTimeout(resizeDebounceTimer);
            resizeDebounceTimer = window.setTimeout(scheduleResize, delay || 120);
        }

        function requestHashScroll() {
            if (!window.location.hash || window.location.hash === '#') {
                return;
            }
            pendingHashScroll = true;
            scheduleResize();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                scheduleResize();
                requestHashScroll();
            }, { once: true });
        } else {
            scheduleResize();
            requestHashScroll();
        }

        window.addEventListener('load', function () {
            scheduleResize();
            requestHashScroll();
        });
        window.addEventListener('pageshow', function () {
            scheduleResize();
            requestHashScroll();
        });
        window.addEventListener('hashchange', requestHashScroll);
        window.addEventListener('resize', function () {
            scheduleResizeDebounced(120);
        });

        var menuToggle = document.getElementById('menuToggle');
        if (menuToggle) {
            menuToggle.addEventListener('change', function () {
                scheduleResize();
                window.setTimeout(scheduleResize, 250);
            });
        }
    })();
</script>
  
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    

<style>
    .code-block-wrapper {
        position: relative;
    }
    .copy-code-button {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 6px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s, background 0.3s;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .copy-code-button svg {
        width: 16px;
        height: 16px;
        fill: #fff;
        transition: fill 0.3s;
    }
    .code-block-wrapper:hover .copy-code-button {
        opacity: 1;
    }
    .copy-code-button:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    .copy-code-button.copied {
        background: rgba(46, 160, 67, 0.8);
        border-color: rgba(46, 160, 67, 1);
    }
    .copy-code-button.copied svg {
        fill: #fff;
    }
</style>
<script type="text/javascript">
    document.addEventListener('DOMContentLoaded', function() {
        
        document.querySelectorAll('pre code').forEach(function(codeBlock) {
            var pre = codeBlock.parentNode;
            
            
            if (pre.parentNode.classList.contains('code-block-wrapper')) {
                return;
            }
            
            
            var wrapper = document.createElement('div');
            wrapper.className = 'code-block-wrapper';
            pre.parentNode.insertBefore(wrapper, pre);
            wrapper.appendChild(pre);
            
            
            var button = document.createElement('button');
            button.className = 'copy-code-button';
            button.innerHTML = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
            button.setAttribute('aria-label', '复制代码');
            button.setAttribute('title', '复制代码');
            
            var copyIcon = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z"></path><path d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z"></path></svg>';
            var checkIcon = '<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"></path></svg>';
            
            
            button.addEventListener('click', function() {
                var code = codeBlock.textContent;
                navigator.clipboard.writeText(code).then(function() {
                    button.innerHTML = checkIcon;
                    button.classList.add('copied');
                    button.setAttribute('aria-label', '已复制');
                    button.setAttribute('title', '已复制');
                    setTimeout(function() {
                        button.innerHTML = copyIcon;
                        button.classList.remove('copied');
                        button.setAttribute('aria-label', '复制代码');
                        button.setAttribute('title', '复制代码');
                    }, 2000);
                }).catch(function(err) {
                    console.error('复制失败:', err);
                });
            });
            
            wrapper.appendChild(button);
        });
    });
</script>




    



</body>

</html>
