<!DOCTYPE html>
<html lang="zh-CN">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/redis/redis-persistence/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.149.0">

    
    
    

<title>Redis持久化机制-aof.c与rdb.c • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Redis持久化机制-aof.c与rdb.c">
  <meta name="twitter:description" content="redis提供aof和rdb两种持久化机制，本文分析一下这两种持久化机制
两种持久化机制的优劣 以下先摘录一下redis文档关于rdb、aof持久化的优势和劣势">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/redis/redis-persistence/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Redis持久化机制-aof.c与rdb.c">
  <meta property="og:description" content="redis提供aof和rdb两种持久化机制，本文分析一下这两种持久化机制
两种持久化机制的优劣 以下先摘录一下redis文档关于rdb、aof持久化的优势和劣势">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-09-11T20:17:11+08:00">
    <meta property="article:modified_time" content="2019-09-11T20:17:11+08:00">
    <meta property="article:tag" content="Redis">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.484b96856b25751067d56c8c0af9dc1fd6372707029b6d56ee178da6bead45b5.css" integrity="sha256-SEuWhWsldRBn1WyMCvncH9Y3JwcCm21W7heNpr6tRbU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.0873834b0f2e9fdc9e1d0301e8ebce21fc10383882a41e9373f29b90e85a9987.css" integrity="sha256-CHODSw8un9yeHQMB6OvOIfwQODiCpB6Tc/KbkOhamYc=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana/d/a0d0b2fe-285a-44ba-8509-a404961d6da49/rust-http-proxy">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="http://beian.miit.gov.cn/">
						<span>沪ICP备2025110448号</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    
<div class="copyright">
  &copy; 2025 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>
        <div class="content container">
            
    
<article>
  <header>
    <h1>Redis持久化机制-aof.c与rdb.c</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Sep 11, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/redis">REDIS</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/redis">redis</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 11 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#两种持久化机制的优劣">两种持久化机制的优劣</a></li>
    <li><a href="#主从架构下主节点是否应该开启持久化">主从架构下主节点是否应该开启持久化</a></li>
    <li><a href="#rdb实现机制简析">rdb实现机制简析</a></li>
    <li><a href="#rdbload-加载rdb文件">rdbLoad-加载rdb文件</a></li>
    <li><a href="#aof实现">AOF实现</a></li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>redis提供aof和rdb两种持久化机制，本文分析一下这两种持久化机制</p>
<h2 id="两种持久化机制的优劣">两种持久化机制的优劣</h2>
<p>以下先摘录一下redis文档关于rdb、aof持久化的优势和劣势</p>
<p>redis提供两种持久化方式：RDB和AOF</p>
<ul>
<li>RDB以一定的时间间隔提供redis数据集的实时快照</li>
<li>AOF则记录redis的每一次写操作。在redis重启时，会重新执行这些操作。这些操作以redis网络通信协议的格式记录。采用追加写的方式。如果AOF文件太大，redis可以在后台重写这些日志（啥叫rewrite？）</li>
<li>如果愿意，可以完全禁用数据持久化，如果没有持久化的需求</li>
<li>RDB和AOF能够同时存在，当两者都存在时，会使用AOF进行恢复，因为AOF会更加完整</li>
</ul>
<p><strong>RDB的优势</strong></p>
<ul>
<li>RDB以一个紧凑的单一文件备份redis的实时数据。RDB文件非常适合备份。比如你希望每个小时备份一下RDB文件，从而存储不同版本的数据以应对可能出现的灾难</li>
<li>RDB很适合用于灾难恢复，因为单一的紧凑的文件很容易迁移到另一个较远的数据中心</li>
<li>RDB最大化了redis的性能，因为redis父进程仅需要fork一个子进程去完成剩余的工作，而不需要处理IO等会产生阻塞的事件。</li>
<li>RDB恢复的启动时间小于AOF恢复</li>
</ul>
<p><strong>RDB的劣势</strong></p>
<ul>
<li>RDB会丢失部分数据，因为他是定时地进行备份。如果Redis没有经历正常的关闭过程（断电等），则会丢失上一次RDB到异常关闭这段时间的写。</li>
<li>RDB需要fork子进程来进行持久化。如果数据集太大，fork系统调用可能消耗较多时间，甚至导致redis暂停服务（ n ms-1s）。AOF也需要fork，但是你可以在不影响持久性的前提下控制多久重写一次日志</li>
</ul>
<p><strong>AOF的优势</strong></p>
<ul>
<li>使用AOF的话，redis具有更高的持久性。你可以选择不同的fsync（将磁盘写缓冲区的数据冲刷到磁盘-真正写到磁盘）策略：不做fsync，每秒做一次fsync，每次查询做一次fsync。在默认策略-每秒执行一次fsync时，性能仍然很客观，而只会丢失一秒的写。</li>
<li>AOF是一个尾部追加写的文件，不会做任何的seek操作（定位到文件的中间位置再进行写）。所以即使发生断电，也不会造成AOF文件的污染。如果断电时仅仅成功地写了一半的命令，也可以通过redis-check-aof工具进行修正。</li>
<li>redis可以在后台重写AOF当日志文件变得很大。重写是完全安全的。当新日志文件创建并准备就绪后，新的追加会立即切换到新日志文件。</li>
<li>AOF记录了写的操作顺序。如果想要撤销某个操作例如flushall，仅需要删除AOF文件中的flushalll的命令，并重启redis即可。</li>
</ul>
<p><strong>AOF的劣势</strong></p>
<ul>
<li>AOF文件通常会比同数据集的RDB文件大</li>
<li>AOF在特定的fsync策略下会影响性能。总体来说，在每秒一次fsync时，性能仍然很高；当关闭fsync时，会和RDB有差不多一样的性能。另外在高负载时，RDB的最大延迟比AOF低。</li>
<li>AOF曾经有一些bug。【技术人真严谨，讲了好几条</li>
</ul>
<h2 id="主从架构下主节点是否应该开启持久化">主从架构下主节点是否应该开启持久化</h2>
<p>先说结论：如果主节点没有开启持久化，那么主节点的进程千万不能有崩溃后自动重启机制。崩溃后自动重启可以通过systemd的restart=always等方式进行配置。考虑如下场景：</p>
<ol>
<li>A是主节点，B、C是他的从节点，从A获取异步拷贝。A没有开启持久化，并且A节点通过systemd配置了崩溃后自动重启</li>
<li>A崩溃后立即自动重启，因为没有持久化所有数据被清空，因为崩溃的时间间隔短，sentinel或cluster来不及提升其他从节点，A重启后仍然为主节点。</li>
<li>B、C仍然从A获取拷贝，他们也清空了自己的数据。</li>
</ol>
<p>该场景下，导致数据最终丢失。</p>
<p>所以主从架构下，主节点要么开启持久化，要么不能有自动重启机制。</p>
<h2 id="rdb实现机制简析">rdb实现机制简析</h2>
<p>rdb简单地理解就是将内存数据快照一下，redis提供SAVE和BGSAVE两种命令，其中SAVE会暂停redis服务，BGSAVE则是在后台进行。</p>
<p>将内存数据快照这件事，很容易想到JVM进行full GC前stop the world获取内存快照进行可达性分析，这样不难理解为什么redis的SAVE会暂停redis服务。</p>
<p>而BGSAVE则使用fork()系统调用创建子进程来进行内存快照，从而实现不暂停服务进行快照。redis文档用一句话总结为什么新开进程，而不是新开线程：利用copy-on-write机制。</p>
<p>在这里展开来讲一下。如果我们开新的线程，进行快照是要对整块内存数据加锁的，开新线程并不能并行地备份+提供服务。而fork机制新建的子进程，在一开始与父进程共享内存空间，只有当父子进程的内存出现不一致时，父子才使用不同的内存空间去承载这不同的部分——这就是copyonwirte机制，可以理解为一种“懒”的机制。fork出的子进程拥有父进程（redis主进程）的全部内存数据，子进程将自己的内存数据快照，即将本节点当时的内存快照下来，而redis主进程继续向客户端提供服务。利用fork机制，可以实现不暂停服务进行快照。——这可能是为数不多的进程优于线程的情况。</p>
<p>在进行BGSAVE时，redis会产生一条日志：<code>RDB: %zu MB of memory used by copy-on-write</code>，记录在rdb过程中，父子进程产生了多少内存的差异。redis对统计<code>/proc/self/smaps</code>文件下的<code>Private_dirty</code>的总和来计算copy-on-write内存。可以使用一下命令自己看看Private_dirty的情况：<code>cat /proc/self/smaps | grep Private_Dirty</code>。linux的哲学是一切皆文件，/proc目录就是一个虚拟文件，用于保存系统运行时的状态。而/proc/self文件夹下永远呈现查看该目录内容的进程的情况——rdb子进程看到的是自己的情况，我们cat /proc/self/smaps则看到的是cat进程的信息。</p>
<blockquote>
<p>PS:因为copyonwrite机制，在进行rdb时，redis的内存占用会出现膨胀的状况。例如原来只占用8GB，进行rdb时可能会膨胀到10GB。。。</p></blockquote>
<blockquote>
<p>PS:如果内存膨胀超过机器内存，此时rdb会失败。</p></blockquote>
<blockquote>
<p>考虑从节点要获取全量同步的情况，如果主节点因内存不足导致rdb失败，从节点会重试请求全量同步，主节点仍然会rdb失败。这会循环。。</p></blockquote>
<p><strong>rdbSaveRio</strong></p>
<p>rdb的核心实现是rdbSaveRio。其函数声明如下：</p>
<pre tabindex="0"><code>int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi)
</code></pre><p>其中rio指针类型的rdb参数是redisIO模型对linux文件描述符的一个封装，rio既可以是磁盘文件描述符也可以是socket描述符。第二个参数记录write系统调用的errno，通过指针的方式进行“透传”，执行完毕后仍能查看看error的值。</p>
<p>rdbSaveRio会做下面这些事：</p>
<ol>
<li>写入魔数“REDIS”以及RDB_VERSION</li>
<li>保存AUX字段（可以认为是redis的状态元数据）</li>
<li>遍历数据库，执行4、5</li>
<li>写入“RDB_OPCODE_SELECTDB 数据库号”和“RDB_OPCODE_RESIZEDB 数据库大小 设置expire的key-value的大小”</li>
<li>遍历数据库的dict中的key-value，写入<code>[EXPIRETIME time] type key value</code></li>
<li>写入RDB_OPCODE_EOF ——EOF标志</li>
<li>写入checksum</li>
</ol>
<p>rdb的核心实现就是以上。另外，redis在主从拷贝中可以直接传输rdb到socket连接而不使用磁盘存储（diskless），redis定义了rdbSaveRioWithEOFMark和rdbSaveToSlavesSockets两个函数来实现以上功能。依赖于rio封装linux文件描述符（磁盘/socket）的设计，这两个函数最终还是使用rdbSaveRio。</p>
<h2 id="rdbload-加载rdb文件">rdbLoad-加载rdb文件</h2>
<p>rdbLoad函数是rdbSave的逆过程，实现感觉没有必要细说。rdb加载通常发生在redis启动时，redis不允许管理员在运行时加载rdb文件，实际上这是可以的，仅仅是redis没有暴露相关的接口。</p>
<p>在这里简单记录一下如何实现这个功能，以备不时之需。因为篇幅和内容相关性的原因，这里仅给出链接，不列原文。<a href="/posts/redis/redis-online-load-rdb/">redis运行时加载rdb</a>。</p>
<h2 id="aof实现">AOF实现</h2>
<p>AOF会记录write请求，将其写入aof文件。从redis接受一个请求到写入AOF的函数调用路径为：</p>
<ol>
<li>processCommand @server.c
<ol>
<li>call @server.c
<ol>
<li>propagate @server.c
<ol>
<li>feedAppendOnlyFile @aof.c</li>
<li>replicationFeedSlaves @replicate.c</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>从该路径可以清晰地看到server处理命令后最终走到了aof功能和replicate功能的代码。</p>
<p><strong>将命令追加到aof_buf</strong></p>
<p>feedAppendOnlyFile会对expire类型的命令进行翻译，将过期时翻译为绝对的过期时间戳，伪代码表示：</p>
<pre tabindex="0"><code>void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {
    如果databaseID不等于上次使用的databaseID{
        追加select命令
    }

    如果命令为EXPIRE/PEXPIRE/EXPIREAT{
        翻译为PEXPIREAT，然后追加
    }

    如果命令为SETEX/PSETEX{
        翻译为SET+PEXPIREAT两条命令，然后追加
    }

    如果命令为SET [EX seconds][PX milliseconds]{
        翻译为SET+PEXPIREAT两条命令，然后追加
    }

    其他情况{
        直接追加命令
    }
}
</code></pre><p>feedAppendOnlyFile并不直接将命令追加到aof文件，而是追加到server.aof_buf这个缓存，之后再通过其他途径写入磁盘。如果有后台rewriting正在执行，则同时将这些命令写入aofRewrite缓冲区（aof_rewrite_buf_blocks）。</p>
<p><strong>将aof_buf真正写入aof文件</strong></p>
<p>真正将buf写到磁盘的函数是flushAppendOnlyFile。该函数会调用一次write，将aof_buf写入aof的文件描述符。同时，会根据appendfsync配置（always、everysec、no）的值和当前是否有后台线程执行fsync，决定现在执行fsync还是延迟fsync。</p>
<p>write系统调用并不会立即将数据落到磁盘，落盘由操作系统调度，fsync则是强制操作系统进行落盘。</p>
<p><strong>加载AOF文件</strong></p>
<p>由函数loadAppendOnlyFile实现。</p>
<p>读取AOF中的命令tcp报文再执行，修改redis的database中数据，这是加载AOF文件的流程。因为redis的实现中，每一个命令的执行都需要一个struct client实例,同样执行AOF中的命令也需要一个这样的client。所以redis伪造了一个client来执行这些命令——通过createFakeClient函数。</p>
<p>在读取/加载AOF文件过程中，会首先判断是否AOF文件是否已“REDIS”开头，如果是，则认为这个文件是rdb+aof。则先读取该文件的rdb部分，再读取尾部的aof部分。从aof中读取到命令后，将命令参数设置到fakeclient中，然后将fakeClient作为参数传递给命令对应的cmd函数，这就完成了该条命令的执行。</p>
<p><strong>重写AOF文件实现</strong></p>
<p>AOF文件使用追加的方式记录redis的写命令历史，也就意味着AOF文件会不断增大，“重写”就是当AOF文件过大时，创建新的AOF文件，以减小单个AOF文件的大小。</p>
<p>其实实现在rewriteAppendOnlyFileBackground。redis会fork出一个子进程。子进程创建名为“temp-rewriteaof-bg-{child_pid}.aof”的临时文件。随后调用rewriteAppendOnlyFile(tempfile)。</p>
<p>rewrite的整体过程是：先将当前redis的快照保存到新AOF文件中，然后将aof_rewrite_buf_blocks中的缓冲写到新的AOF文件中</p>
<p>rewriteAppendOnlyFile会根据server.aof_use_rdb_preamble是否设定，决定rewirte是否使用rdb作当前redis的快照。其关键代码为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (server.aof_use_rdb_preamble) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rdbSaveRio</span>(<span style="color:#f92672">&amp;</span>aof,<span style="color:#f92672">&amp;</span>error,RDB_SAVE_AOF_PREAMBLE,NULL) <span style="color:#f92672">==</span> C_ERR) {
</span></span><span style="display:flex;"><span>            errno <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> werr;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rewriteAppendOnlyFileRio</span>(<span style="color:#f92672">&amp;</span>aof) <span style="color:#f92672">==</span> C_ERR) <span style="color:#66d9ef">goto</span> werr;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>rewriteAppendOnlyFileRio保存当前redis快照的方式是遍历所有database，将所有key-value用set命令的形式追加到新的AOF文件中（超时的key不追加，超时时间使用PEXPIREAT记录）。</p>
<p>serverCron函数会检测AOF重写子进程的退出，其实现是通过wait系统调用——linux中子进程退出，父进程要wait其退出，否则该子进程会成为僵尸进程。</p>
<p>如果serverCron中wait得到的进程id与AOF重写子进程相同，则说明AOF重写完成，此时通过<code>backgroundRewriteDoneHandler</code>函数执行重写完毕后的操作。关键代码如下：</p>
<pre tabindex="0"><code>        if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) {
            ...
            if (pid == -1) {
                ...
            } else if (pid == server.rdb_child_pid) {
                ...
            } else if (pid == server.aof_child_pid) {
                backgroundRewriteDoneHandler(exitcode,bysignal);
                if (!bysignal &amp;&amp; exitcode == 0) receiveChildInfo();
            } else {
                ...
            }
            ...
        }
</code></pre><p>backgroundRewriteDoneHandler关键代码如下：</p>
<pre tabindex="0"><code>void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    if (!bysignal &amp;&amp; exitcode == 0) {
        snprintf(tmpfile,256,&#34;temp-rewriteaof-bg-%d.aof&#34;,
            (int)server.aof_child_pid);
        newfd = open(tmpfile,O_WRONLY|O_APPEND);
        if (aofRewriteBufferWrite(newfd) == -1) {
            ……//将重写缓冲区的数据写入到重写AOF文件
        }
        if (rename(tmpfile,server.aof_filename) == -1) {
            ……//覆盖旧的AOF文件
        }
        ……
    } 
}
</code></pre><p>他会将重写期间暂时存放在aof_rewrite_buf_blocks中的写请求追加到新的AOF文件，随后覆盖就得AOF文件。</p>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/libuv-install/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Libuv教程</span>
    </a>
    
    
    <a href="/posts/redis/sentinel/" class="navigation-next">
      <span class="navigation-tittle">Redis哨兵实现-sentinel.c</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


        </div>
        
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    




    



    </body>
</html>
