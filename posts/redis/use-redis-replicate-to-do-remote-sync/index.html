<!DOCTYPE html>
<html lang="zh-CN">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/redis/use-redis-replicate-to-do-remote-sync/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.136.4">

    
    
    

<title>Redis异步拷贝实现—replicate.c • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Redis异步拷贝实现—replicate.c">
  <meta name="twitter:description" content="为实现redis异地数据中心实时同步功能，存在几种方案。其中一种方案是利用redis主从节点的异步拷贝，伪装一个slave节点，获取主节点的异步拷贝信息。将该异步拷贝信息同步到异地数据中心，从而实现redis集群异地同步。
本文的目的就是探究“伪装slave获取异步拷贝”的可行性与复杂度。
虽然redis文档有介绍主从以及异步拷贝，但是其实现并没有详细介绍，因此我阅读了redis中的cluster.c、replicate.c（redis版本为4.0.1），探查redis&#34;主从拷贝&#34;实现的细节，并使用netcat软件进行了一些实验。我们的最终结论是：实验结果反映“伪装slave获取异步拷贝”方案是可行的，并且复杂度可接受。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/redis/use-redis-replicate-to-do-remote-sync/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Redis异步拷贝实现—replicate.c">
  <meta property="og:description" content="为实现redis异地数据中心实时同步功能，存在几种方案。其中一种方案是利用redis主从节点的异步拷贝，伪装一个slave节点，获取主节点的异步拷贝信息。将该异步拷贝信息同步到异地数据中心，从而实现redis集群异地同步。
本文的目的就是探究“伪装slave获取异步拷贝”的可行性与复杂度。
虽然redis文档有介绍主从以及异步拷贝，但是其实现并没有详细介绍，因此我阅读了redis中的cluster.c、replicate.c（redis版本为4.0.1），探查redis&#34;主从拷贝&#34;实现的细节，并使用netcat软件进行了一些实验。我们的最终结论是：实验结果反映“伪装slave获取异步拷贝”方案是可行的，并且复杂度可接受。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-09-03T23:44:09+08:00">
    <meta property="article:modified_time" content="2019-09-03T23:44:09+08:00">
    <meta property="article:tag" content="Redis">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.484b96856b25751067d56c8c0af9dc1fd6372707029b6d56ee178da6bead45b5.css" integrity="sha256-SEuWhWsldRBn1WyMCvncH9Y3JwcCm21W7heNpr6tRbU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.0873834b0f2e9fdc9e1d0301e8ebce21fc10383882a41e9373f29b90e85a9987.css" integrity="sha256-CHODSw8un9yeHQMB6OvOIfwQODiCpB6Tc/KbkOhamYc=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="http://beian.miit.gov.cn/">
						<span>苏ICP备17024437号</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    
<div class="copyright">
  &copy; 2024 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>
        <div class="content container">
            
    
<article>
  <header>
    <h1>Redis异步拷贝实现—replicate.c</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Sep 3, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/redis">REDIS</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/redis">redis</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 11 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#为什么可行复杂度为什么可接受">为什么可行？（复杂度为什么可接受）</a></li>
    <li><a href="#异步拷贝机制简介">异步拷贝机制简介</a></li>
    <li><a href="#源码解析">源码解析</a></li>
    <li><a href="#实验也是将来的实现">实验——也是将来的实现</a>
      <ul>
        <li><a href="#模拟第一次全量同步">模拟第一次全量同步</a></li>
        <li><a href="#模拟以后的增量同步">模拟以后的增量同步</a></li>
      </ul>
    </li>
    <li><a href="#伪装slave的副作用">伪装slave的副作用</a></li>
    <li><a href="#主节点psync实现">主节点PSYNC实现</a></li>
    <li><a href="#参考文档">参考文档：</a></li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>为实现redis异地数据中心实时同步功能，存在几种方案。其中一种方案是利用redis主从节点的异步拷贝，伪装一个slave节点，获取主节点的异步拷贝信息。将该异步拷贝信息同步到异地数据中心，从而实现redis集群异地同步。</p>
<p>本文的目的就是探究“伪装slave获取异步拷贝”的可行性与复杂度。<br>
虽然redis文档有介绍主从以及异步拷贝，但是其实现并没有详细介绍，因此我阅读了redis中的<code>cluster.c</code>、<code>replicate.c</code>（redis版本为4.0.1），探查redis&quot;主从拷贝&quot;实现的细节，并使用netcat软件进行了一些实验。我们的最终结论是：实验结果反映“伪装slave获取异步拷贝”方案是可行的，并且复杂度可接受。</p>
<h2 id="为什么可行复杂度为什么可接受">为什么可行？（复杂度为什么可接受）</h2>
<p><strong>1.redis集群和master-slave 依赖 异步拷贝机制，而不是反过来的那样</strong></p>
<p>—— 实现slave的异步拷贝不需要处理redis集群的协议。复杂度比预期的低很多。</p>
<p><strong>2. 我们仅需要实现“异步拷贝”，而不需要实现slave其他的功能，例如选举、failover</strong></p>
<p>—— 我们的方案一直被称之为“伪slave”，我们也一直觉得需要实现一个完整的slave。其实不需要，我们仅需要实现“异步拷贝”，异步拷贝不依赖slave的其他功能。</p>
<p>以上两点是在阅读源码、进行实验后确定的，恰恰证明了大幅度提升复杂度的细节我们都不需要处理，也证明了该方案的可行性。</p>
<p>关于可行性，“实验”章节展示了获取异步拷贝的正常流程，很直观。看完该实验，相信大家能直观地感受该方案的可行性。</p>
<h2 id="异步拷贝机制简介">异步拷贝机制简介</h2>
<p>redis使用主从异步拷贝机制实现较高的可用性。其宏观流程如下：</p>
<ol>
<li>客户端向mater节点写</li>
<li>主节点通知客户端写成功（+OK）</li>
<li>主节点向slave节点推送该写请求</li>
</ol>
<p>所谓异步拷贝就是不等待slave成功拷贝，即向客户端发送成功响应。其中的问题是拷贝可能会有部分写丢失，当slave被选举为master时，这一部分丢失就导致了不一致。采取异步拷贝的设计是redis架构设计中性能与可用性的权衡。</p>
<p>异步拷贝机制是master-slave机制重要的一部分。redis的高可用方案：哨兵和redis cluster都是基于master-slave的异步拷贝。在单主节点+从节点的中，可以使用<code>SLAVEOF IP PORT</code>命令宣称自己是某节点的从节点，从而接收异步拷贝信息。在redis cluster中，需要使用<code>CLUSTER REPLICATE &lt;NODE ID&gt;</code>来实现相同的功能。两者不能混用，但他们都获取了主节点的ip和port，这也是slave获取master拷贝实际上唯一需要的信息。</p>
<p>从微观流程看，异步拷贝会在第一次拷贝时传播rdb文件，进行一次全量同步，之后通过<code>offset</code>偏移量这个变量进行增量同步。<code>runid </code>和<code>offset</code>一起确定增量同步的起点，每收到一个字节，<code>offset</code>增加一。其整体工作原理如下（从SLAVE的视角看）：</p>
<ol>
<li>调用SLAVEOF或CLUSTER REPLICATE命令，获取master的ip、port</li>
<li>redis的定时任务创建到master的tcp连接（在发现没有有效连接的情况下）</li>
<li>通过该tcp连接发送<code>PING AUTH REPLCONF</code>等指令，完成与master的握手</li>
<li>如果是第一次拿拷贝，没有<code>runid </code>和<code>offset</code>，转到5。如果不是第一次拿拷贝，则转到6</li>
<li>发送<code>PSYNC ? -1</code>，接收master的rdb格式的全量同步数据、<code>runid </code>和<code>offset</code>。rdb接收完毕后，redis加载rdb文件，而后转到7</li>
<li>发送<code>PSYNC runid  offset</code>，收到<code>+CONTINUE runid</code>，表示主节点继续“增量”地发送异步拷贝信息 ，转到7。（PS：这里仅覆盖runid和offset有效的情况，关于有效性和无效时的表现在《主节点PSYNC实现》有叙）</li>
<li>主节点会不断发送自己收到的写请求的tcp报文，从节点执行这些写请求，并增加offset。直到该tcp连接异常断开，转到2（定时任务创建新的连接）</li>
</ol>
<h2 id="源码解析">源码解析</h2>
<p>以上微观流程就是从redis源码中总结出来的。我是从<code>CLUSTER REPLICATE &lt;NODE ID&gt;</code>指令的实现找到redis源码的打开口的。</p>
<p><code>CLUSTER REPLICATE &lt;NODE ID&gt;</code>指定自己拷贝nodeID所指的主节点（也就是成为他的从节点）。其实现在<code>cluster.c</code>。其关键步骤为调用<code>clusterSetMaster(n);</code>这获取了主节点的ip和port，这将在之后的异步拷贝中使用到。</p>
<p>另外一方面，<code>serverCron</code>函数每秒钟被执行一次，其中有<code>replicationCron();</code></p>
<p><code>replicationCron</code>会通过<code>connectWithMaster</code>连接上主节点的ip和port。连接成功的回调事件是：<code>syncWithMaster</code>。（replicationCron的其他部分会启动发送rdb数据的延时任务）</p>
<p><code>syncWithMaster</code>会发送握手所需的<code>PING</code>、<code>AUTH &lt;passwd&gt;</code>(可选)、<code>REPLCONF listening-port &lt;port&gt;</code>、<code>REPLCONF ip-address &lt;ip&gt;</code>(可选)、<code>REPLCONF capa eof capa psync2</code>。以上即完成握手环节，下面开始真正的同步。</p>
<p>同步分为<code>PSYNC ? -1</code>和<code>PSYNC runid  offset</code>，其实现在<code>slaveTryPartialResynchronization</code>函数中。该函数会根据<code>runid </code>是否有效决定是传输rdb进行全量同步，还是利用<code>offset</code>进行增量同步（这句话很概括，详情见《主节点PSYNC实现》）。</p>
<p>在传输rdb全量同步时，从节点会使用<code>readSyncBulkPayload</code>函数读取rdb内容，并写入临时rdb文件。最终使用<code>rdbLoad</code>加载该rdb文件到redis内存。</p>
<p>redis源码挺好读的，并且有丰富的注释。在这里没有贴详细的代码，相信按照这个顺序去读<code>replicate.c</code>的代码，大家都能清楚地理解slave获取异步拷贝的流程。</p>
<h2 id="实验也是将来的实现">实验——也是将来的实现</h2>
<p>代码不会骗人，所以我按照阅读源码后总结出的步骤，使用<code>nc</code>向redis主节点发送相关命令，最终获取了异步拷贝。</p>
<h3 id="模拟第一次全量同步">模拟第一次全量同步</h3>
<p>执行<code>nc ip port</code>后，依次输入：</p>
<pre tabindex="0"><code>PING
REPLCONF listening-port 8888
REPLCONF capa eof capa psync2
PSYNC ? -1
</code></pre><p>控制台输出（redis的响应）如下：</p>
<pre tabindex="0"><code>$nc 99.47.149.27 6428
PING
+PONG
REPLCONF listening-port 8888
+OK
REPLCONF capa eof capa psync2
+OK
PSYNC ? -1
+FULLRESYNC b8e7eba438f7ee357d2f0978a9ed307ef250e1fd 3638988293
$272
REDIS0008▒      redis-ver4.0.1▒
redis-bits▒@▒ctime▒zDn]used-mem▒▒▒,▒repl-stream-db▒▒▒
aof-preamble▒▒repl-id(b8e7eba438f7ee357d2f0978a9ed307ef250e1fd▒
                                                               repl-offset
3638988293▒▒▒
{a}aaaaaaaaaaaaaa▒{{a}aaa▒}aaaaaa
aaaaa▒*1        {a}a▒
$4
PING
*1
$4
PING
*1
$4
PING
</code></pre><p>我们通过该实验模拟第一次获取异步拷贝的情况，即上一节我们提到的流程3-&gt;5-&gt;7。</p>
<p>我们执行<code>PSYNC ? -1</code>，返回<code>+FULLRESYNC runid offset</code>——第一次不知道runid和offset；返回全量同步标志、runid和offset。</p>
<p><code>$272</code>表示rdb全量同步，一共有272字节——这是一个基于长度的tcp流分割方案</p>
<p>在输出的最后我们看到好几个PING，这是redis集群其他节点发送过来的请求，被主节点异步地发送给我们实验的这个伪slave。</p>
<h3 id="模拟以后的增量同步">模拟以后的增量同步</h3>
<p>执行<code>nc ip port</code>后，依次输入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PING
</span></span><span style="display:flex;"><span>REPLCONF listening-port <span style="color:#ae81ff">8888</span>
</span></span><span style="display:flex;"><span>REPLCONF capa eof capa psync2
</span></span><span style="display:flex;"><span>PSYNC b8e7eba438f7ee357d2f0978a9ed307ef250e1fd <span style="color:#ae81ff">3638988293</span>
</span></span></code></pre></div><p>控制台输出（redis的响应）如下：</p>
<pre tabindex="0"><code>$nc 99.47.149.27 6428
PING
+PONG
REPLCONF listening-port 8888
+OK
REPLCONF capa eof capa psync2
+OK
PSYNC b8e7eba438f7ee357d2f0978a9ed307ef250e1fd 3638988293
+CONTINUE b8e7eba438f7ee357d2f0978a9ed307ef250e1fd

*1
$4
PING
*1
$4
PING
*2
$6
SELECT
$1
0
*3
$3
set
$7
{a}test
$3
vvv
</code></pre><p>这次实验的runid和offset都为有效值，表示一次从offset开始的增量同步。</p>
<p><code>+CONTINUE runid</code>（PSYNC2协议下的新响应）表示继续这个replicate的同步，而不是一次全新的同步。</p>
<p>后面这个tcp连接就收到master转发的来自cluster其他节点的PING命令的拷贝。之后的SLECT、set是我手动set时出现的异步拷贝。</p>
<p>以上实验，是在阅读redis4.0.1源码中replicate.c，确定其tcp协议细节后进行的，覆盖了简单的正常流程。</p>
<h2 id="伪装slave的副作用">伪装slave的副作用</h2>
<p>我们拿主节点的异步拷贝，主节点会不会认为我们是他的真实的slave，而导致sentinel、redis cluster这些技术想要将我们纳入管理呢？</p>
<p>初步结论是：</p>
<ol>
<li>
<p>redis cluster中不会产生副作用，使用<code>cluster nodes</code>查看了主从节点分布，没有看到伪slave的信息。</p>
</li>
<li>
<p>sentinel中会产生副作用，原因如下：</p>
<ol>
<li>sentinel是从主节点中获取从节点信息</li>
<li>使用<code>info replication</code>命令查看主节点的从节点时，看到了我们伪装的从节点(下图所示的slave1)。最终导致，sentinel认为我们是真实的slave。</li>
<li>根据sentinel文档，slave只要offset够小，并且超时时间够长，sentinel是不会选择该slave成为master的。所以该副作用不会导致伪slave被sentinel提升为master，影响不大。</li>
</ol>
</li>
</ol>
<pre tabindex="0"><code>connected_slaves:2
slave0:ip=99.47.149.27,port=6429,state=online,offset=3639193829,lag=0
slave1:ip=99.47.149.26,port=8888,state=online,offset=0,lag=17 
</code></pre><p>解释一下上述<code>slave1</code>信息的含义：slave1是我们伪装的从节点，lag字段表示多久没有收到REPLCONF命令 offset需要使用 <code>REPLCONF ack &lt;offset&gt;</code>来设定。而redis源码注释说，这是一个内部命令，所以正常的客户端永远不应该使用，但我们不正常（笑）。在以上测试中我们没有做ack，发现不影响psync的正常工作。</p>
<h2 id="主节点psync实现">主节点PSYNC实现</h2>
<p>以上内容我们主要是从slave的角度看异步拷贝实现，下面我们主节点收到<code>PSYNC</code>之后是如何处理的。这部分处理在<code>syncCommand</code>函数中。</p>
<p>首先会检查<code>PSYNC</code>的参数，检查是否能进行增量同步，如果能进行增量同步，则直接响应<code>+CONTINUE</code>。随后该条tcp连接用于传输增量同步的redis命令报文。</p>
<p>是否能进行增量同步根据<code>runid</code>和<code>offset</code>决定。redis内部数据结构中保存有replicID1、offset1和replicateID2、offset2。在一般情况下replicateID2为0，如果该节点接替某原主节点成为主节点，则其replicateID2为原主节点的replicateID1。只要runid和replicID1、replicID2中的一个相同，则有进行增量同步的可能。其次检查offset是否在“备份积压缓冲”范围中，如果在，则可以进行增量同步。这一部分判断在<code>masterTryPartialResynchronization</code>函数中，如下：</p>
<pre tabindex="0"><code>strcasecmp(master_replid, server.replid) &amp;&amp;
(strcasecmp(master_replid, server.replid2) ||
psync_offset &gt; server.second_replid_offset)
</code></pre><p>设计两个replicID的目的是就是为了应对从节点被提升为主节点时，避免没有必要的全量同步（该特性由psync2引入）</p>
<p>如果不能进行增量同步，则首先要通过rdb进行全量同步。全量同步根据是否有BGSAVE在执行和是否支持diskless全量拷贝会出现如下几种情况:</p>
<ol>
<li>使用diskless全量同步，diskless是指磁盘不暂存rdb文件而是直接通过tcp传输rdb文件。此时会等待delay后由eplicationCron启动startBgsaveForReplication。delay的意义是等多其他slave，再开始同步。</li>
<li>不使用diskless全量同步，先rdb到磁盘再tcp传输。
<ol>
<li>如果有正在进行的BGSAVE，则尝试attach该slave到该次BGSAVE。如果失败则等待delay，然后由replicationCron启动startBgsaveForReplication</li>
<li>如果没有正在进行的BGSAVE，直接启动startBgsaveForReplication</li>
</ol>
</li>
</ol>
<blockquote>
<p>PS: BGSAVE是后台执行rdb文件导出的过程</p>
</blockquote>
<p>是否使用diskless，由redis的配置项<code>repl-diskless-sync yes</code>、<code>repl-diskless-sync-delay 5</code>与伪slave是否发送<code>REPLCONF capa eof</code>控制。在这三个条件都满足时，用于全量同步的RDB不会暂存在磁盘，而是直接网络传输。其tcp传输的结束标志也不再是长度标志(实验中的<code>$272</code>)，而是<code>$EOF:&lt;40 bytes delimiter&gt;</code>（<code>rdbSaveRioWithEOFMark</code>函数中有体现）。</p>
<p>在完成全量同步后，该条tcp连接用于传输增量同步的redis命令报文。</p>
<h2 id="参考文档">参考文档：</h2>
<ul>
<li>redis源码——replicate.c</li>
<li>redis文档</li>
<li><a href="https://mp.weixin.qq.com/s/ROQofjE5WwdAltazQ5p0QQ">psync2新特性</a></li>
</ul>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/redis/redis-document/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Redis文档摘要</span>
    </a>
    
    
    <a href="/posts/redis/redis-online-load-rdb/" class="navigation-next">
      <span class="navigation-tittle">实现redis运行时加载rdb文件</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


        </div>
        
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    




    



    </body>
</html>
