<!DOCTYPE html>
<html lang="zh-CN">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    
    <link rel="canonical" href="https://www.arloor.com/posts/redis/psync2/">
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.150.0">

    
    
    

<title>Psync2——redis备份机制的发展【转载】 • ARLOOR</title>
<meta name="description" content="今天，你学习了吗">
<meta name="keywords" content="刘港欢, arloor, moontell">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Psync2——redis备份机制的发展【转载】">
  <meta name="twitter:description" content="今天的正题是想转发一篇关于“异步拷贝”发展的博文，写的真的好，忍不住想转发。看完不禁感叹redis的牛逼，有种兴叹汪洋的感觉。。">
      <meta name="twitter:site" content="@njulgh">

<meta property="og:url" content="https://www.arloor.com/posts/redis/psync2/">
  <meta property="og:site_name" content="ARLOOR">
  <meta property="og:title" content="Psync2——redis备份机制的发展【转载】">
  <meta property="og:description" content="今天的正题是想转发一篇关于“异步拷贝”发展的博文，写的真的好，忍不住想转发。看完不禁感叹redis的牛逼，有种兴叹汪洋的感觉。。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-09-05T21:20:30+08:00">
    <meta property="article:modified_time" content="2019-09-05T21:20:30+08:00">
    <meta property="article:tag" content="Redis">


    





<link rel="stylesheet" href="/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.484b96856b25751067d56c8c0af9dc1fd6372707029b6d56ee178da6bead45b5.css" integrity="sha256-SEuWhWsldRBn1WyMCvncH9Y3JwcCm21W7heNpr6tRbU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">




<link rel="stylesheet" href="/scss/hugo-toc.0873834b0f2e9fdc9e1d0301e8ebce21fc10383882a41e9373f29b90e85a9987.css" integrity="sha256-CHODSw8un9yeHQMB6OvOIfwQODiCpB6Tc/KbkOhamYc=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">
          
          ARLOOR
          
        </a>
      </span>
      <a href="/">
        
        
        <div class="author-image">
          <img src="/img/head.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
        
      </a>
      
      <p class="site__description">
         都是瞎写的 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">ARLOOR</label>
      <div class="menu-content">
        <div class="show-in-small">
          <a href="/">
            
            
            <div class="author-image">
              <img src="/img/head.jpeg" alt="Author Image"
                class="img--circle img--headshot element--center">
            </div>
            
            
          </a>
        </div>
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>文章</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/tags/">
						<span>分类</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>关于我</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/grafana/d/a0d0b2fe-285a-44ba-8509-a404961d6da49/rust-http-proxy">
						<span>Grafana</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="http://beian.miit.gov.cn/">
						<span>沪ICP备2025110448号</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://x.com/njulgh" rel="me"><i class="fa-brands fa-x-twitter fa-lg"></i></a>
	
	
	
	
	
	<a href="https://github.com/arloor" rel="me"><i class="fa-brands fa-github fa-lg"></i></a>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a href="https://t.me/never_contact_me" rel="me"><i class="fa-brands fa-telegram fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	<a href="mailto:admin@arloor.com" rel="me"><i class="fa-solid fa-at fa-lg"></i></a>
	
	
	
	
</section>
      </div>
    </div>
    
<div class="copyright">
  &copy; 2025 arloor
  
    <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/arloor/hyde-arloor">hyde-arloor</a>.
</div>


  </div>
</div>
        <div class="content container">
            
    
<article>
  <header>
    <h1>Psync2——redis备份机制的发展【转载】</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Sep 5, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/redis">REDIS</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/redis">redis</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 12 min read
</div>


  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
          <nav id="TableOfContents">
  <ul>
    <li><a href="#正文">正文</a></li>
    <li><a href="#1-什么是redis部分重新同步-psync">1 什么是Redis部分重新同步-psync</a>
      <ul>
        <li><a href="#redis28-psync1解决什么问题">Redis2.8 psync1解决什么问题</a></li>
        <li><a href="#psync1的基本实现">psync1的基本实现</a></li>
        <li><a href="#psync1的不足">psync1的不足</a></li>
      </ul>
    </li>
    <li><a href="#2-psync2的实现简述">2 psync2的实现简述</a></li>
    <li><a href="#3-redis从实例重启的部分重新同步">3 Redis从实例重启的部分重新同步</a>
      <ul>
        <li><a href="#redis关闭时持久化复制信息到rdb">redis关闭时，持久化复制信息到RDB</a></li>
        <li><a href="#redis启动读取rdb中复制信息">redis启动读取RDB中复制信息</a></li>
        <li><a href="#redis从实例尝试部分重新同步">redis从实例尝试部分重新同步</a></li>
        <li><a href="#redis重启时临时调整主实例的复制积压缓冲区大小">redis重启时，临时调整主实例的复制积压缓冲区大小</a></li>
      </ul>
    </li>
    <li><a href="#4-psync2实现redis-cluster-failover部分全新同步">4 psync2实现Redis Cluster Failover部分全新同步</a></li>
  </ul>
</nav>
      
    </div>
  
  
  <div class="post">
    <p>今天的正题是想转发一篇关于<a href="https://mp.weixin.qq.com/s/ROQofjE5WwdAltazQ5p0QQ">“异步拷贝”发展的博文</a>，写的真的好，忍不住想转发。看完不禁感叹redis的牛逼，有种兴叹汪洋的感觉。。</p>
<blockquote>
<p>PS: 这篇博文疑似基于redis4.0.1版本的redis</p></blockquote>
<h2 id="正文">正文</h2>
<p>Redis4.0新特性psync2(partial resynchronization version2)部分重新同步(partial resync)增加版本；主要解决Redis运维管理过程中，从实例重启和主实例故障切换等场景带来的全量重新同步(full resync)问题。</p>
<h2 id="1-什么是redis部分重新同步-psync">1 什么是Redis部分重新同步-psync</h2>
<p>redis部分重新同步：是指redis因某种原因引起复制中断后，从库重新同步时，只同步主实例的差异数据(写入指令），不进行bgsave复制整个RDB文件。</p>
<p>本文的名词规约：<br>
部分重新同步：后文简称<strong>psync</strong> <br>
全量重新同步：后文简称<strong>fullsync</strong>  <br>
redis2.8第一版部分重新同步：后文简称<strong>psync1</strong>
redis4.0第二版本部分重新同步：后文简称<strong>psync2</strong></p>
<p>在说明psync2功能前，先简单阐述redis2.8版本发布的psync1</p>
<h3 id="redis28-psync1解决什么问题">Redis2.8 psync1解决什么问题</h3>
<p>在psync1功能出现前，redis复制秒级中断，就会触发从实例进行fullsync。<br>
每一次的fullsync，集群的性能和资源使用都可能带来抖动；如果redis所处的网络环境不稳定，那么fullsync的出步频率可能较高。为解决此问题，redis2.8引入psync1, 有效地解决这种复制闪断，带来的影响。redis的fullsync对业务而言，算是比较“重”的影响；对性能和可用性都有一定危险。</p>
<p>这里列举几个fullsync常见的影响：</p>
<ul>
<li>master需运行bgsave,出现fork()，可能造成master达到毫秒或秒级的卡顿(latest_fork_usec状态监控)；</li>
<li>redis进程fork导致Copy-On-Write内存使用消耗(后文简称COW)，最大能导致master进程内存使用量的消耗。(eg 日志中输出 RDB: 5213 MB of memory used by copy-on-write)</li>
<li>redis slave load RDB过程，会导致复制线程的client output buffer增长很大；增大Master进程内存消耗；</li>
<li>redis保存RDB(不考虑disless replication),导致服务器磁盘IO和CPU(压缩)资源消耗</li>
<li>发送数GB的RDB文件,会导致服务器网络出口爆增,如果千兆网卡服务器，期间会影响业务正常请求响应时间(以及其他连锁影响)</li>
</ul>
<h3 id="psync1的基本实现">psync1的基本实现</h3>
<p>因为psync2是在psync1基础上的增强实现，介绍psync2之前，简单分析psync1的实现。</p>
<p>redis2.8为支持psync1，引入了replication backlog buffer(后文称：复制积压缓冲区）；复制积压缓冲区是redis维护的固定长度缓冲队列(由参数repl-backlog-size设置，默认1MB)，master的写入命令在同步给slaves的同时，会在缓冲区中写入一份(master只有1个积压缓冲区，所有slaves共享）。</p>
<p>当redis复制中断后，slave会尝试采用psync, 上报原master runid + 当前已同步master的offset(复制偏移量，类似mysql的binlog file和position)；</p>
<p>如果runid与master的一致，且复制偏移量在master的复制积压缓冲区中还有(即offset &gt;= min(backlog值)，master就认为部分重同步成功，不再进行全量同步。</p>
<pre tabindex="0"><code>部分重同步成功，master的日志显示如下：

30422:M 04 Aug 14:33:48.505 * Slave xxxxx:10005 asks for synchronization
30422:M 04 Aug 14:33:48.506 * Partial resynchronization request from xxx:10005 accepted. Sending 0 bytes of backlog starting from offset 6448313.
</code></pre><p>redis2.8的部分同步机制，有效解决了网络环境不稳定、redis执行高时间复杂度的命令引起的复制中断，从而导致全量同步。但在应对slave重启和Master故障切换的场景时，psync1还是需进行全量同步。</p>
<h3 id="psync1的不足">psync1的不足</h3>
<p>从上文可知，psync1需2个条件同时满足，才能成功psync: <strong>master runid不变 和复制偏移量在master复制积缓冲区中</strong>。
那么在redis slave重启,因master runid和复制偏移量都会丢失，需进行全量重同步；redis master发生故障切换，因master runid发生了变化；故障切换后，新的slave需进行全量重同步。而slave维护性重启、master故障切换都是redis运维常见场景，为redis的psync1是不能解决这两类场景的成功部分重同步问题。</p>
<p>因此redis4.0的加强版部分重同步功能-psync2，主要解决这两类场景的部分重新同步。</p>
<h2 id="2-psync2的实现简述">2 psync2的实现简述</h2>
<p>在redis cluster的实际生产运营中，实例的维护性重启、主实例的故障切换（如cluster failover)操作都是比较常见的(如实例升级、rename command和释放实例内存碎片等）。而在redis4.0版本前，这类维护性的处理，redis都会发生全量重新同步，导到性能敏感的服务有少量受损。
如前文所述，psync2主要让redis在从实例重启和主实例故障切换场景下，也能使用部分重新同步。本节主要简述psync2在这两种场景的逻辑实现。</p>
<p>名词解释：</p>
<ul>
<li>master_replid : 复制ID1(后文简称：replid1)，一个长度为41个字节(40个随机串+’\0’)的字符串。redis实例都有，和runid没有直接关联，但和runid生成规则相同，都是由getRandomHexChars函数生成。当实例变为从实例后，自己的replid1会被主实例的replid1覆盖。</li>
<li>master_replid2：复制ID2(后文简称:replid2),默认初始化为全0，用于存储上次主实例的replid1</li>
</ul>
<p>实例的replid信息，可通过info replication进行查看； 示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6385&gt; info replication
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Replication</span>
</span></span><span style="display:flex;"><span>role:slave
</span></span><span style="display:flex;"><span>master_host:xxxx      // IP模糊处理
</span></span><span style="display:flex;"><span>master_port:6382
</span></span><span style="display:flex;"><span>master_link_status:up
</span></span><span style="display:flex;"><span>slave_repl_offset:119750
</span></span><span style="display:flex;"><span>master_replid:fe093add4ab71544ce6508d2e0bf1dd0b7d1c5b2  //这里是主实例的replid1相同
</span></span><span style="display:flex;"><span>master_replid2:0000000000000000000000000000000000000000  //未发生切换，即主实例未发生过变化，所以是初始值全<span style="color:#e6db74">&#34;0&#34;</span>master_repl_offset:119750
</span></span><span style="display:flex;"><span>second_repl_offset:-1
</span></span></code></pre></div><h2 id="3-redis从实例重启的部分重新同步">3 Redis从实例重启的部分重新同步</h2>
<p>在之前的版本，redis重启后，复制信息是完全丢失;所以从实例重启后，只能进行全量重新同步。</p>
<p>redis4.0为实现重启后，仍可进行部分重新同步，主要做以下3点：</p>
<ol>
<li>
<p>redis关闭时，把复制信息作为辅助字段(AUX Fields)存储在RDB文件中；以实现同步信息持久化；</p>
</li>
<li>
<p>redis启动加载RDB文件时，会把复制信息赋给相关字段；</p>
</li>
<li>
<p>redis重新同步时，会上报repl-id和repl-offset同步信息，如果和主实例匹配，且offset还在主实例的复制积压缓冲区内，则只进行部分重新同步。</p>
</li>
</ol>
<p>接下来，我们详细分析每步的简单实现</p>
<h3 id="redis关闭时持久化复制信息到rdb">redis关闭时，持久化复制信息到RDB</h3>
<p>redis在关闭时，通过shutdown save,都会调用rdbSaveInfoAuxFields`函数，把当前实例的repl-id和repl-offset保存到RDB文件中。    <br>
说明：当前的RDB存储的数据内容和复制信息是一致性的。熟悉MySQL的同学，可以认为MySQL中全量备份数和binlog信息是一致的。       <br>
rdbSaveInfoAuxFields函数实现在rdb.c源文件中，省略后代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Save a few default AUX fields with information about the RDB generated. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rdbSaveInfoAuxFields</span>(rio <span style="color:#f92672">*</span>rdb, <span style="color:#66d9ef">int</span> flags, rdbSaveInfo <span style="color:#f92672">*</span>rsi) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Add a few fields about the state when the RDB was created. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rdbSaveAuxFieldStrStr</span>(rdb,<span style="color:#e6db74">&#34;redis-ver&#34;</span>,REDIS_VERSION) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//把实例的repl-id和repl-offset作为辅助字段，存储在RDB中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rdbSaveAuxFieldStrStr</span>(rdb,<span style="color:#e6db74">&#34;repl-id&#34;</span>,server.replid) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rdbSaveAuxFieldStrInt</span>(rdb,<span style="color:#e6db74">&#34;repl-offset&#34;</span>,server.master_repl_offset) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>生成的RDB文件，可以通过redis自带的<code>redis-check-rdb</code>工具查看辅助字段信息。<br>
其中repl两字段信息和info中的相同；</p>
<pre tabindex="0"><code>$shell&gt; /src/redis-check-rdb  dump.rdb      
[offset 0] Checking RDB file dump.rdb
[offset 26] AUX FIELD redis-ver = &#39;4.0.1&#39;[offset 133] AUX FIELD repl-id = &#39;44873f839ae3a57572920cdaf70399672b842691&#39;
[offset 148] AUX FIELD repl-offset = &#39;0&#39;[offset 167] \o/ RDB looks OK! \o/
[info] 1 keys read
[info] 0 expires
[info] 0 already expired
</code></pre><h3 id="redis启动读取rdb中复制信息">redis启动读取RDB中复制信息</h3>
<p>redis实例启动读取RDB文件，通过rdb.c文件中<code>rdbLoadRio()</code>函数实现。 <br>
redis加载RDB文件，会专门处理文件中辅助字段(AUX fields）信息，把其中repl_id和repl_offset加载到实例中，分别赋给master_replid和master_repl_offset两个变量值。 <br>
以下代码，是从RDB文件中读取两个辅助字段值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rdbLoadRio</span>(rio <span style="color:#f92672">*</span>rdb, rdbSaveInfo <span style="color:#f92672">*</span>rsi) {
</span></span><span style="display:flex;"><span><span style="color:#f92672">----------</span><span style="color:#960050;background-color:#1e0010">省略</span><span style="color:#f92672">-----------</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">strcasecmp</span>(auxkey<span style="color:#f92672">-&gt;</span>ptr,<span style="color:#e6db74">&#34;repl-id&#34;</span>)) {<span style="color:#75715e">//读取的aux字段是repl-id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (rsi <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sdslen</span>(auxval<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">==</span> CONFIG_RUN_ID_SIZE) {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">memcpy</span>(rsi<span style="color:#f92672">-&gt;</span>repl_id,auxval<span style="color:#f92672">-&gt;</span>ptr,CONFIG_RUN_ID_SIZE<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                    rsi<span style="color:#f92672">-&gt;</span>repl_id_is_set <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">strcasecmp</span>(auxkey<span style="color:#f92672">-&gt;</span>ptr,<span style="color:#e6db74">&#34;repl-offset&#34;</span>)) { 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (rsi) rsi<span style="color:#f92672">-&gt;</span>repl_offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtoll</span>(auxval<span style="color:#f92672">-&gt;</span>ptr,NULL,<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* We ignore fields we don&#39;t understand, as by AUX field
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                 * contract. */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">serverLog</span>(LL_DEBUG,<span style="color:#e6db74">&#34;Unrecognized RDB AUX field: &#39;%s&#39;&#34;</span>,
</span></span><span style="display:flex;"><span>                    (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)auxkey<span style="color:#f92672">-&gt;</span>ptr);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="redis从实例尝试部分重新同步">redis从实例尝试部分重新同步</h3>
<p>redis实例重启后，从RDB文件中加载(注：此处不讨论AOF和RDB加载优先权）master_replid和master_repl_offset；相当于实例的server.cached_master。当我们把它作为某个实例的从库时（包含如被动的cluster slave或主动执行slaveof指令)，实例向主实例上报master_replid和master_repl_offset+1；从实例同时满足以下两条件，就可以部分重新同步：</p>
<ol>
<li>从实例上报master_replid串，与主实例的master_replid1或replid2有一个相等</li>
<li>从实例上报的master_repl_offset+1字节，还存在于主实例的复制积压缓冲区中</li>
</ol>
<p>从实例尝试部分重新同步函数slaveTryPartialResynchronization;主实例判断能否进行部分重新同步函数masterTryPartialResynchronization。</p>
<h3 id="redis重启时临时调整主实例的复制积压缓冲区大小">redis重启时，临时调整主实例的复制积压缓冲区大小</h3>
<p>redis的复制积压缓冲区是通过参数repl-backlog-size设置，默认1MB；为确保从实例重启后，还能部分重新同步，需设置合理的repl-backlog-size值。</p>
<p><strong>1 计算合理的repl-backlog-size值大小</strong></p>
<p>通过主库每秒增量的master复制偏移量master_repl_offset(info replication指令获取)大小，
如每秒offset增加是5MB,那么主实例复制积压缓冲区要保留最近60秒写入内容，backlog_size设置就得大于300MB(60*5)。而从实例重启加载RDB文件是较耗时的过程，如重启某个重实例需120秒(RDB大小和CPU配置相关），那么主实例backlog_size就得设置至少600MB.</p>
<pre tabindex="0"><code>计算公式：backlog_size = 重启从实例时长 * 主实例offset每秒写入量
</code></pre><p><strong>2 重启从实例前，调整主实例的动态调整repl-backlog-size的值。</strong></p>
<p>因为通过config set动态调整redis的repl-backlog-size时，redis会释放当前的积压缓冲区，重新分配一个指定大小的缓冲区。 所以我们必须在从实例重启前，调整主实例的repl-backlog-size。</p>
<p>调整backlog_size处理函数resizeReplicationBacklog，代码逻辑如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resizeReplicationBacklog</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> newsize) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newsize <span style="color:#f92672">&lt;</span> CONFIG_REPL_BACKLOG_MIN_SIZE) <span style="color:#75715e">//如果设置新值小于16KB,则修改为16KB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        newsize <span style="color:#f92672">=</span> CONFIG_REPL_BACKLOG_MIN_SIZE;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (server.repl_backlog_size <span style="color:#f92672">==</span> newsize) <span style="color:#66d9ef">return</span>; <span style="color:#75715e">//如果新值与原值相同，则不作任何处理，直接返回。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    server.repl_backlog_size <span style="color:#f92672">=</span> newsize;  <span style="color:#75715e">//修改backlog参数大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (server.repl_backlog <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">//当backlog内容非空时，释放当前backlog，并按新值分配一个新的backlog
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/* What we actually do is to flush the old buffer and realloc a new
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * empty one. It will refill with new data incrementally.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * The reason is that copying a few gigabytes adds latency and even
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * worse often we need to alloc additional space before freeing the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * old buffer. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zfree</span>(server.repl_backlog);
</span></span><span style="display:flex;"><span>        server.repl_backlog <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(server.repl_backlog_size);
</span></span><span style="display:flex;"><span>        server.repl_backlog_histlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//修改backlog内容长度和首字节offset都为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        server.repl_backlog_idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Next byte we have is... the next since the buffer is empty. */</span>
</span></span><span style="display:flex;"><span>        server.repl_backlog_off <span style="color:#f92672">=</span> server.master_repl_offset<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4-psync2实现redis-cluster-failover部分全新同步">4 psync2实现Redis Cluster Failover部分全新同步</h2>
<p>为解决主实例故障切换后，重新同步新主实例数据时使用psync，而分fullsync；</p>
<ol>
<li>redis4.0使用两组replid、offset替换原来的master runid和offset.</li>
<li>redis slave默认开启复制积压缓冲区功能；以便slave故障切换变化master后，其他落后从可以从缓冲区中获取写入指令。</li>
</ol>
<p><strong>第一组：master_replid和master_repl_offset</strong></p>
<p>如果redis是主实例，则表示为自己的replid和复制偏移量； 如果redis是从实例，则表示为自己主实例的replid1和同步主实例的复制偏移量。</p>
<p><strong>第二组：master_replid2和second_repl_offset</strong></p>
<p>无论主从，都表示自己上次主实例repid1和复制偏移量；用于兄弟实例或级联复制，主库故障切换psync。<br>
初始化时, 前者是40个字符长度为0，后者是-1； 只有当主实例发生故障切换时，redis把自己replid1和master_repl_offset+1分别赋值给master_replid2和second_repl_offset。<br>
这个交换逻辑实现在函数shiftReplicationId中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shiftReplicationId</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memcpy</span>(server.replid2,server.replid,<span style="color:#66d9ef">sizeof</span>(server.replid)); <span style="color:#75715e">//replid赋值给replid2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/* We set the second replid offset to the master offset + 1, since
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the slave will ask for the first byte it has not yet received, so
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * we need to add one to the offset: for example if, as a slave, we are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * sure we have the same history as the master for 50 bytes, after we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * are turned into a master, we can accept a PSYNC request with offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 51, since the slave asking has the same history up to the 50th
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * byte, and is asking for the new bytes starting at offset 51. */</span>
</span></span><span style="display:flex;"><span>    server.second_replid_offset <span style="color:#f92672">=</span> server.master_repl_offset<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">changeReplicationId</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">serverLog</span>(LL_WARNING,<span style="color:#e6db74">&#34;Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s&#34;</span>, server.replid2, server.second_replid_offset, server.replid);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样发生主库故障切换，以下三种常见结构，都能进行psync:</p>
<ol>
<li>一主一从发生切换，A-&gt;B 切换变成 B-&gt;A ;</li>
<li>一主多从发生切换，兄弟节点变成父子节点时；</li>
<li>级别复制发生切换， A-&gt;B-&gt;C 切换变成 B-&gt;C-&gt;A</li>
</ol>
<p>主实例判断能否进行psync的逻辑函数在<code>masterTryPartialResynchronization()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">masterTryPartialResynchronization</span>(client <span style="color:#f92672">*</span>c) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果slave提供的master_replid与master的replid不同，且与master的replid2不同，或同步速度快于master； 就必须进行fullsync.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strcasecmp</span>(master_replid, server.replid) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">strcasecmp</span>(master_replid, server.replid2) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         psync_offset <span style="color:#f92672">&gt;</span> server.second_replid_offset))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Run id &#34;?&#34; is used by slaves that want to force a full resync. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (master_replid[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;?&#39;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strcasecmp</span>(master_replid, server.replid) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">strcasecmp</span>(master_replid, server.replid2))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">serverLog</span>(LL_NOTICE,<span style="color:#e6db74">&#34;Partial resynchronization not accepted: &#34;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Replication ID mismatch (Slave asked for &#39;%s&#39;, my &#34;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;replication IDs are &#39;%s&#39; and &#39;%s&#39;)&#34;</span>,
</span></span><span style="display:flex;"><span>                    master_replid, server.replid, server.replid2);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">serverLog</span>(LL_NOTICE,<span style="color:#e6db74">&#34;Partial resynchronization not accepted: &#34;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Requested offset for second ID was %lld, but I can reply &#34;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;up to %lld&#34;</span>, psync_offset, server.second_replid_offset);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">serverLog</span>(LL_NOTICE,<span style="color:#e6db74">&#34;Full resync requested by slave %s&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">replicationGetSlaveName</span>(c));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> need_full_resync;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* We still have the data our slave is asking for? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>server.repl_backlog <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        psync_offset <span style="color:#f92672">&lt;</span> server.repl_backlog_off <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>        psync_offset <span style="color:#f92672">&gt;</span> (server.repl_backlog_off <span style="color:#f92672">+</span> server.repl_backlog_histlen))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">serverLog</span>(LL_NOTICE,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).&#34;</span>, <span style="color:#a6e22e">replicationGetSlaveName</span>(c), psync_offset);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (psync_offset <span style="color:#f92672">&gt;</span> server.master_repl_offset) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">serverLog</span>(LL_WARNING,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;Warning: slave %s tried to PSYNC with an offset that is greater than the master replication offset.&#34;</span>, <span style="color:#a6e22e">replicationGetSlaveName</span>(c));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> need_full_resync;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/redis/redis-online-load-rdb/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">实现redis运行时加载rdb文件</span>
    </a>
    
    
    <a href="/posts/libuv-install/" class="navigation-next">
      <span class="navigation-tittle">Libuv教程</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  


</article>


        </div>
        
    



<script defer src="/js/all.js" crossorigin="anonymous"></script>

    
    
    <script src="/js/highlight.min.js"></script>
    <script src="/js/languages/dos.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.highlightAll();
    </script>
    




    



    </body>
</html>
